{"version":3,"file":"fileuploader.min.js","sources":["../../../src/local/courseeditor/fileuploader.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * The course file uploader.\n *\n * This module is used to upload files directly into the course.\n *\n * @module     core_courseformat/local/courseeditor/fileuploader\n * @copyright  2022 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Config from 'core/config';\nimport events from 'core_course/events';\nimport log from 'core/log';\nimport ModalFactory from 'core/modal_factory';\nimport ModalEvents from 'core/modal_events';\nimport Templates from 'core/templates';\nimport UploadMonitor from 'core_courseformat/local/courseeditor/uploadmonitor';\nimport {getFirst} from 'core/normalise';\nimport {prefetchStrings} from 'core/prefetch';\nimport {get_string as getString} from 'core/str';\nimport {getCourseEditor} from 'core_courseformat/courseeditor';\nimport {Reactive} from 'core/reactive';\n\n// Uploading url.\nconst uploadUrl = Config.wwwroot + '/course/dndupload.php';\n\n/** @var {FileUploader} uploader the internal reactive uploader.  */\nlet uploader = null;\n\nconst initialState = {\n    process: {\n        current: 0,\n        maxbytes: 0,\n    },\n    pending: [],\n    uploading: [],\n};\n\n// Load global strings.\nprefetchStrings('moodle', ['addresourceoractivity', 'upload']);\n\n/**\n * The reactive file uploader class.\n *\n * As all the upload queues are reactive, any plugin can implement its own upload monitor.\n *\n * @module     core_courseformat/local/courseeditor/fileuploader\n * @class     core_courseformat/local/courseeditor/fileuploader\n * @copyright  2021 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nclass FileUploader extends Reactive {\n\n    /** @var {Map} editorUpdates the courses pending to be updated. */\n    editorUpdates = new Map();\n\n    /** @var {Object} lastHandlers the last handler name. */\n    lastHandlers = {};\n\n    /**\n     * Refresh all pending course refreshes.\n     */\n    refreshCourseEditors() {\n        // Get pending refreshes.\n        const refreshes = this.editorUpdates;\n        this.editorUpdates = new Map();\n        // Iterate all pending refreshes.\n        refreshes.forEach((sectionIds, courseId) => {\n            const courseEditor = getCourseEditor(courseId);\n            if (courseEditor) {\n                courseEditor.dispatch('sectionState', [...sectionIds]);\n            }\n        });\n    }\n\n    /**\n     * Add a section to refresh.\n     * @param {number} courseId the course id\n     * @param {number} sectionId the seciton id\n     */\n    addRefreshSection(courseId, sectionId) {\n        let refresh = this.editorUpdates.get(courseId);\n        if (!refresh) {\n            refresh = new Set();\n        }\n        refresh.add(sectionId);\n        this.editorUpdates.set(courseId, refresh);\n    }\n\n    /**\n     * Starts the current file upload.\n     */\n    async processCurrent() {\n        const item = this.currentItem;\n        if (!item) {\n            return;\n        }\n        const courseEditor = getCourseEditor(item.courseId);\n        if (!courseEditor) {\n            return;\n        }\n        // Get the handlers list from the course editor.\n        const allFileHandlers = await courseEditor.getFileHandlersPromise();\n        const fileHandlers = getFileHandlers(item.fileInfo, allFileHandlers);\n        if (fileHandlers.length == 0) {\n            // Show unkown file warning.\n        }\n        if (fileHandlers.length == 1) {\n            this.dispatch('uploadItem', item, fileHandlers[0]);\n            return;\n        }\n        if (fileHandlers.length > 0) {\n            this._showUploadModal(fileHandlers);\n            return;\n        }\n    }\n\n    /**\n     * Get the file handlers of an specific file.\n     * @private\n     * @param {Array} fileHandlers the course file handlers\n     */\n    async _showUploadModal(fileHandlers) {\n        const item = uploader.currentItem;\n        const extension = getFileExtension(item.fileInfo);\n        if (!item) {\n            return;\n        }\n        const data = {\n            filename: item.fileInfo.name,\n            uploadid: item.id,\n            handlers: [],\n        };\n        let hasDefault = false;\n        fileHandlers.forEach((handler, index) => {\n            const isDefault = (this.lastHandlers[extension] == handler.module);\n            data.handlers.push({\n                ...handler,\n                selected: isDefault,\n                labelid: `fileuploader_${data.uploadid}`,\n                value: index,\n            });\n            hasDefault = hasDefault || isDefault;\n        });\n        if (!hasDefault && data.handlers.length > 0) {\n            const lastHandler = data.handlers.pop();\n            lastHandler.selected = true;\n            data.handlers.push(lastHandler);\n        }\n        // Build the modal parameters from the event data.\n        const modalParams = {\n            title: getString('addresourceoractivity', 'moodle'),\n            body: Templates.render('core_courseformat/fileuploader', data),\n            type: ModalFactory.types.SAVE_CANCEL,\n            saveButtonText: getString('upload', 'moodle'),\n        };\n        // Create the modal.\n        const modal = await modalBodyRenderedPromise(modalParams);\n        const modalBody = getFirst(modal.getBody());\n\n        modal.getRoot().on(\n            ModalEvents.save,\n            event => {\n                // Get the selected option.\n                const index = modalBody.querySelector('input:checked').value;\n                event.preventDefault();\n                modal.destroy();\n                if (fileHandlers[index]) {\n                    this.dispatch('uploadItem', item, fileHandlers[index]);\n                    // Save last selected handler.\n                    this.lastHandlers[extension] = fileHandlers[index].module;\n                }\n            }\n        );\n        modal.getRoot().on(\n            ModalEvents.cancel,\n            () => {\n                this.dispatch('discardItem', item);\n            }\n        );\n    }\n\n    /**\n     * Starts a file uploading.\n     * @param {Object} item the pending item\n     * @param {String} item.id the upload id\n     * @param {String} item.courseId the course id\n     * @param {String} item.sectionId the section id\n     * @param {File} item.fileInfo the file info\n     * @param {Object} fileHandler the file handler object\n     */\n    startUploading(item, fileHandler) {\n        if (this.maxbytes > 0 && item.fileInfo.size > this.maxbytes) {\n            log.error(`File size over the limit: ${item.fileInfo.name}`);\n            uploader.dispatch('finishUpload', item.id, false);\n            return;\n        }\n        uploadFile(item, fileHandler);\n    }\n\n    /**\n     * Return the current pending item.\n     * @return {Object} the current item.\n     */\n    get currentItem() {\n        return this.state.pending.get(this.state.process.current);\n    }\n\n    /**\n     * Return the maxbytes.\n     * @return {number}\n     */\n    get maxbytes() {\n        // TODO: move maxbytes to course state.\n        return this.state.process.maxbytes;\n    }\n}\n\n/** @var {number} lastUploadId the last upload id. */\nlet lastUploadId = 0;\n\n/**\n * @var {Object} the upload queue mutations.\n */\nconst mutations = {\n    /**\n     * Add a new pending file.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {number} courseId the course id\n     * @param {number} sectionId the course id\n     * @param {number} sectionNum the course number\n     * @param {File} fileInfo the file info\n     */\n    addPending: function(stateManager, courseId, sectionId, sectionNum, fileInfo) {\n        // Generate uploadId and data structure.\n        lastUploadId++;\n        const item = {\n            id: lastUploadId,\n            courseId,\n            sectionId,\n            sectionNum,\n            fileInfo,\n            percent: 0,\n        };\n        // Adds a new element to the pending queue.\n        const state = stateManager.state;\n        stateManager.setReadOnly(false);\n        state.pending.add(item);\n        stateManager.setReadOnly(true);\n        // Send the process next pending.\n        this.processNextPending(stateManager);\n    },\n    /**\n     * Discards the current pending file and starts the next processing.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {Object} item the item to discard\n     * @param {number} item.id the item id\n     */\n    discardItem: function(stateManager, item) {\n        const state = stateManager.state;\n        if (!state.pending.has(item.id)) {\n            return;\n        }\n        // Remove the current pending element.\n        stateManager.setReadOnly(false);\n        state.pending.delete(state.process.current);\n        if (state.process.current == item.id) {\n            state.process.current = 0;\n        }\n        stateManager.setReadOnly(true);\n        // Send the process next pending.\n        if (state.process.current == 0) {\n            this.processNextPending(stateManager);\n        }\n    },\n    /**\n     * Upload the current file an starts the next processing.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {Object} item the item to discard\n     * @param {number} item.id the item id\n     * @param {Object} fileHandler the file handler object\n     */\n    uploadItem: function(stateManager, item, fileHandler) {\n        this.discardItem(stateManager, item);\n        const state = stateManager.state;\n        // Move element to uploading.\n        stateManager.setReadOnly(false);\n        state.uploading.add({...item});\n        stateManager.setReadOnly(true);\n        // Init upload process.\n        uploader.startUploading(item, fileHandler);\n    },\n\n    /**\n     * Starts the next processing.\n     *\n     * @param {StateManager} stateManager the current state manager\n     */\n    processNextPending: function(stateManager) {\n        // Check if there is any ongoing process (exit if so)\n        const state = stateManager.state;\n        if (state.process.current != 0) {\n            return;\n        }\n        if (state.pending.size == 0) {\n            return;\n        }\n        // Set the new current pending element.\n        stateManager.setReadOnly(false);\n        const [firstKey] = state.pending.keys();\n        state.process.current = firstKey;\n        stateManager.setReadOnly(true);\n        // Send the process function.\n        uploader.processCurrent();\n    },\n    /**\n     * Finishes a uploaded file.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {number} uploadId the upload id to finish\n     * @param {boolean} success if the upload is success or not\n     */\n    finishUpload: function(stateManager, uploadId, success) {\n        const state = stateManager.state;\n        // Get the file.\n        const item = state.uploading.get(uploadId);\n        if (!item) {\n            return;\n        }\n        // Add the course section to refresh queue.\n        if (success) {\n            uploader.addRefreshSection(item.courseId, item.sectionId);\n        }\n        // Remove from the list.\n        stateManager.setReadOnly(false);\n        state.uploading.delete(uploadId);\n        stateManager.setReadOnly(true);\n        // Process the pensing refreshes.\n        if (state.uploading.size == 0) {\n            uploader.refreshCourseEditors();\n        }\n    },\n    /**\n     * Set the upload percentage of a file.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {number} uploadId the upload id to finish\n     * @param {number} percent the new percentage\n     */\n    setPercentage: function(stateManager, uploadId, percent) {\n        const state = stateManager.state;\n        // Get the file.\n        const item = state.uploading.get(uploadId);\n        if (!item) {\n            return;\n        }\n        // Alter the percentage.\n        stateManager.setReadOnly(false);\n        item.percent = percent;\n        stateManager.setReadOnly(true);\n    },\n};\n\n/**\n * Upload a file into the course.\n *\n * @private\n * @param {Object} item the item element to upload\n * @param {File} item.fileInfo the file info\n * @param {number} item.sectionNum the section number.\n * @param {number} item.sectionId the section id.\n * @param {Array} fileHandler the course file handler\n */\nasync function uploadFile(item, fileHandler) {\n    const fileInfo = item.fileInfo;\n\n    const xhr = createXhrRequest(item);\n\n    const formData = createUploadFormData(item, fileHandler, xhr);\n    if (!formData) {\n        log.error(`File read error: ${fileInfo.name}`);\n        uploader.dispatch('finishUpload', item.id, false);\n        return;\n    }\n\n    // Try reading the file to check it is not a folder, before sending it to the server.\n    const reader = new FileReader();\n    reader.onload = function() {\n        // File was read OK - send it to the server.\n        xhr.open(\"POST\", uploadUrl, true);\n        xhr.send(formData);\n    };\n    reader.onerror = function() {\n        // Unable to read the file (it is probably a folder) - display an error message.\n        log.error(`File read error: ${fileInfo.name}`);\n        uploader.dispatch('finishUpload', item.id, false);\n    };\n    if (fileInfo.size > 0) {\n        // If this is a non-empty file, try reading the first few bytes.\n        // This will trigger reader.onerror() for folders and reader.onload() for ordinary, readable files.\n        reader.readAsText(fileInfo.slice(0, 5));\n    } else {\n        // If you call slice() on a 0-byte folder, before calling readAsText, then Firefox triggers reader.onload(),\n        // instead of reader.onerror().\n        // So, for 0-byte files, just call readAsText on the whole file (and it will trigger load/error functions as expected).\n        reader.readAsText(fileInfo);\n    }\n}\n\n/**\n * Generate a upload XHR file request.\n *\n * @private\n * @param {Object} item the item element to upload\n * @param {File} item.fileInfo the file info\n * @param {number} item.sectionNum the section number.\n * @param {number} item.sectionId the section id.\n * @return {XMLHttpRequest} the XHR request\n */\nfunction createXhrRequest(item) {\n    const xhr = new XMLHttpRequest();\n    // Update the progress bar as the file is uploaded\n    xhr.upload.addEventListener(\n        'progress',\n        (event) => {\n            if (event.lengthComputable) {\n                const percent = Math.round((event.loaded * 100) / event.total);\n                uploader.dispatch('setPercentage', item.id, percent);\n            }\n        },\n        false\n    );\n    // Wait for the AJAX call to complete, then update the\n    // dummy element with the returned details\n    xhr.onreadystatechange = () => {\n        if (xhr.readyState == 1) {\n            // Add a 1% just to indicate that it is uploading.\n            uploader.dispatch('setPercentage', item.id, 1);\n        }\n        // State 4 is DONE. Otherwise the connection is still ongoing.\n        if (xhr.readyState != 4) {\n            return;\n        }\n        let success = false;\n        if (xhr.status == 200) {\n            var result = JSON.parse(xhr.responseText);\n            if (result && result.error == 0) {\n                // All OK.\n                uploader.dispatch('setPercentage', item.id, 100);\n                success = true;\n            }\n        }\n        if (!success) {\n            log.error(`Cannot upload file: ${item.fileInfo.name}`);\n        }\n        // Remove from uploading list.\n        uploader.dispatch('finishUpload', item.id, success);\n    };\n    return xhr;\n}\n\n/**\n * Upload a file into the course.\n *\n * @private\n * @param {Object} item the item element to upload\n * @param {File} item.fileInfo the file info\n * @param {number} item.sectionNum the section number.\n * @param {number} item.sectionId the section id.\n * @param {Array} fileHandler the course file handler\n * @return {FormData|null} the new form data object\n */\nfunction createUploadFormData(item, fileHandler) {\n    const fileInfo = item.fileInfo;\n    const formData = new FormData();\n    try {\n        formData.append('repo_upload_file', fileInfo);\n    } catch (e) {\n        return null;\n    }\n    formData.append('sesskey', Config.sesskey);\n    formData.append('course', item.courseId);\n    formData.append('section', item.sectionNum);\n    formData.append('module', fileHandler.module);\n    formData.append('type', 'Files');\n    return formData;\n}\n\n/**\n * Get the file handlers of an specific file.\n * @private\n * @param {File} fileInfo the file info\n * @param {Array} allFileHandlers the course file handlers\n * @return {Array} of handlers\n */\nconst getFileHandlers = function(fileInfo, allFileHandlers) {\n    const extension = getFileExtension(fileInfo);\n    const fileHandlers = [];\n    for (var i = 0; i < allFileHandlers.length; i++) {\n        if (allFileHandlers[i].extension == '*' || allFileHandlers[i].extension == extension) {\n            fileHandlers.push(allFileHandlers[i]);\n        }\n    }\n    return fileHandlers;\n};\n\n/**\n * Extract the file extension from a fileInfo.\n * @param {File} fileInfo\n * @returns {String} the file extension or an empty string.\n */\nfunction getFileExtension(fileInfo) {\n    let extension = '';\n    const dotpos = fileInfo.name.lastIndexOf('.');\n    if (dotpos != -1) {\n        extension = fileInfo.name.substring(dotpos + 1, fileInfo.name.length).toLowerCase();\n    }\n    return extension;\n}\n\n/**\n * Trigger a state changed event.\n *\n * This function will be moved to core_course/events module\n * when the file is migrated to the new JS events structure proposed in MDL-70990.\n *\n * @method dispatchStateChangedEvent\n * @param {object} detail the full state\n * @param {object} target the custom event target (document if none provided)\n */\nfunction dispatchStateChangedEvent(detail, target) {\n    if (target === undefined) {\n        target = document;\n    }\n    target.dispatchEvent(new CustomEvent(events.uploadStateChanged, {\n        bubbles: true,\n        detail: detail,\n    }));\n}\n\n/**\n * Render a modal and return a body ready promise.\n *\n * @private\n * @param {object} modalParams the modal params\n * @return {Promise} the modal body ready promise\n */\nfunction modalBodyRenderedPromise(modalParams) {\n    return new Promise((resolve, reject) => {\n        ModalFactory.create(modalParams).then((modal) => {\n            modal.setRemoveOnClose(true);\n            // Handle body loading event.\n            modal.getRoot().on(ModalEvents.bodyRendered, () => {\n                resolve(modal);\n            });\n            // Configure some extra modal params.\n            if (modalParams.saveButtonText !== undefined) {\n                modal.setSaveButtonText(modalParams.saveButtonText);\n            }\n            modal.show();\n            return;\n        }).catch(() => {\n            reject(`Cannot load modal content`);\n        });\n    });\n}\n\n/**\n * The init method.\n *\n * @return {Promise} state ready promise.\n */\nfunction init() {\n    if (uploader === null) {\n        uploader = new FileUploader({\n            name: `CourseFileUploader`,\n            eventName: events.uploadStateChanged,\n            eventDispatch: dispatchStateChangedEvent,\n            mutations: mutations,\n            state: initialState,\n        });\n        // Create a basic upload monitor.\n        UploadMonitor.init(uploader);\n    }\n    return uploader.getInitialStatePromise();\n}\n\n/**\n * Upload a file to the course.\n *\n * This method will show any necesary modal to handle the request.\n *\n * @param {number} courseId the course id.\n * @param {number} sectionId the section id.\n * @param {number} sectionNum the section number.\n * @param {Array} files and array of files\n */\nexport const uploadFilesToCourse = async function(courseId, sectionId, sectionNum, files) {\n    // Wait for the reactive processor.\n    await init();\n    for (let index = 0; index < files.length; index++) {\n        const fileInfo = files[index];\n        uploader.dispatch('addPending', courseId, sectionId, sectionNum, fileInfo);\n    }\n};\n\nexport const getUploader = function() {\n    return uploader;\n};\n"],"names":["uploadUrl","Config","wwwroot","uploader","initialState","process","current","maxbytes","pending","uploading","FileUploader","Reactive","Map","refreshCourseEditors","refreshes","this","editorUpdates","forEach","sectionIds","courseId","courseEditor","dispatch","addRefreshSection","sectionId","refresh","get","Set","add","set","item","currentItem","allFileHandlers","getFileHandlersPromise","fileHandlers","getFileHandlers","fileInfo","length","_showUploadModal","extension","getFileExtension","data","filename","name","uploadid","id","handlers","hasDefault","handler","index","isDefault","lastHandlers","module","push","selected","labelid","value","lastHandler","pop","modalParams","title","body","Templates","render","type","ModalFactory","types","SAVE_CANCEL","saveButtonText","modal","Promise","resolve","reject","create","then","setRemoveOnClose","getRoot","on","ModalEvents","bodyRendered","undefined","setSaveButtonText","show","catch","modalBodyRenderedPromise","modalBody","getBody","save","event","querySelector","preventDefault","destroy","cancel","startUploading","fileHandler","size","error","xhr","XMLHttpRequest","upload","addEventListener","lengthComputable","percent","Math","round","loaded","total","onreadystatechange","readyState","success","status","result","JSON","parse","responseText","createXhrRequest","formData","FormData","append","e","sesskey","sectionNum","createUploadFormData","reader","FileReader","onload","open","send","onerror","readAsText","slice","uploadFile","state","lastUploadId","mutations","addPending","stateManager","setReadOnly","processNextPending","discardItem","has","delete","uploadItem","firstKey","keys","processCurrent","finishUpload","uploadId","setPercentage","i","dotpos","lastIndexOf","substring","toLowerCase","dispatchStateChangedEvent","detail","target","document","dispatchEvent","CustomEvent","events","uploadStateChanged","bubbles","async","files","eventName","eventDispatch","init","getInitialStatePromise"],"mappings":"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"}