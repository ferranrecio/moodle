{"version":3,"sources":["../../../src/local/editor/reactive.js"],"names":["Reactive","description","eventname","eventdispatch","Error","target","document","createTextNode","statemanager","StateManager","watchers","Map","components","Set","mutations","addEventListener","callWatchersHandler","bind","state","setInitialState","event","dispatchEvent","CustomEvent","detail","action","bubbles","statedata","manager","mutation","hasOwnProperty","getInitialPromise","component","componentname","name","has","handlers","getWatchers","forEach","watch","handler","apply","stateReady","getInitialStatePromise","then","catch","reason","log","error","add","actionname","params","args","mutationfunction"],"mappings":"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","sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Generic reactive module used in the course editor.\n *\n * TODO: This module will be mover to core\\reactive once the new editor dev starts.\n *\n * @module     core_course/editor\n * @package    core_course\n * @copyright  2021 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport log from 'core/log';\nimport StateManager from 'core_course/local/editor/statemanager';\n\n/**\n* Set up general reactive class.\n*\n* The reactive class is responsible for contining the main store,\n* the complete components list that can be used and initialize the main\n* component.\n*\n* @return {void}\n*/\nconst Reactive = class {\n\n    /**\n     * Create a basic reactive manager.\n     *\n     * The instance description can provide information on how the reactive instance will interact with its\n     * components. The properties are:\n     *  - eventname: the custom event name used for state changed\n     *  - eventdispatch: the event dispatch function\n     *  - target (optional): the target of the event dispatch. If not passed a fake element will be created\n     *  - mutations (optional): an object with state mutations functions\n     *  - state (optional): if your state is not async loaded, you can pass directly on creation.\n     *                      Note that passing state on creation will initialize the state, this means\n     *                      setInitialState will throw an exception because the state is already defined.\n     *\n     * @param {object} description reactive manager description.\n     */\n    constructor(description) {\n\n        if (description.eventname === undefined || description.eventdispatch === undefined) {\n            throw new Error(`Reactivity event required`);\n        }\n\n        // To prevent every component from replicating the same eventlistener, each reactive\n        // instance has its own element anchor to propagate state changes internally.\n        // By default the module will create a fake DOM element to target custom evenets but\n        // if all reactive components is constrait to a single element, this can be passed as\n        // target in the description.\n        this.target = description.target ?? document.createTextNode(null);\n\n        this.eventname = description.eventname;\n        this.eventdispatch = description.eventdispatch;\n\n        this.statemanager = new StateManager(this.eventdispatch, this.target);\n        this.watchers = new Map([]);\n        this.components = new Set([]);\n\n        // Mutations can be overridden using setMutations method.\n        this.mutations = description.mutations ?? {};\n\n        // Register the event to alert watchers when specific state change happens.\n        this.target.addEventListener(this.eventname, this.callWatchersHandler.bind(this));\n\n        // Set initial state if we already have it.\n        if (description.state !== undefined) {\n            this.setInitialState(description.state);\n        }\n    }\n\n    /**\n     * State changed listener.\n     *\n     * This function take any change in the course state and send it to the proper watchers.\n     * Any AMD module is free to register as state change listener at a document level,\n     * but components can register as watchers to listen to specific state changes directly.\n     *\n     * To prevent internal state changes from colliding with other reactive instances, only the\n     * general \"state changed\" is triggered at document level. All the internal changes are\n     * triggered at private target level without bubbling. This way any reactive instance can alert\n     * only its own watchers.\n     *\n     * @param {CustomEvent} event\n     */\n    callWatchersHandler(event) {\n        // Execute any registered component watchers.\n        this.target.dispatchEvent(new CustomEvent(event.detail.action, {\n            bubbles: false,\n            detail: event.detail,\n        }));\n    }\n\n    /**\n    * Create the state manager and set the initial state.\n    *\n    * @param {object} statedata the initial state data.\n    */\n    setInitialState(statedata) {\n        this.statemanager.setInitialState(statedata);\n    }\n\n    /**\n    * Set up the mutation manager.\n    *\n    * Note new mutations will be added to the existing ones.\n    *\n    * @method addMutations\n    * @param {Object} manager the new mutation manager\n    */\n    addMutations(manager) {\n        for (const mutation in manager) {\n            if (manager.hasOwnProperty(mutation)) {\n                // Mutations can be a class or just a collection of functions.\n                // In both cases keep the \"this\" value is a good idea.\n                this.mutations[mutation] = manager[mutation].bind(manager);\n            }\n        }\n    }\n\n    /**\n    * Return the current state\n    *\n    * @method getState\n    * @return {object}\n    */\n    getState() {\n        return this.statemanager.state;\n    }\n\n    /**\n    * Return the initial state promise.\n    *\n    * Typically, components does not require to use this promise because registerComponent\n    * will trigger their stateReady method authomatically. But it could be useful for complex\n    * components that require to combine state, template and string loadings.\n    *\n    * @method getState\n    * @return {Promise}\n    */\n    getInitialStatePromise() {\n        return this.statemanager.getInitialPromise();\n    }\n\n    /**\n    * Register a new component.\n    *\n    * Component can provide some optional functions to the reactive module:\n    * - getWatchers: returns an array of watchers\n    * - stateReady: a method to call when the initial state is loaded\n    *\n    * It can also provide some optional attributes:\n    * - name: the component name (default value: \"Unkown component\") to customize debug messages.\n    *\n    * @method registerComponent\n    * @param {Object} component the new component\n    */\n    registerComponent(component) {\n\n        const componentname = component.name ?? 'Unkown component';\n\n        // Components can be registered only ones.\n        if (this.components.has(component)) {\n            return;\n        }\n\n        // Register watchers.\n        let handlers = [];\n        if (component.getWatchers !== undefined) {\n            handlers = component.getWatchers();\n        }\n        handlers.forEach(({watch, handler}) => {\n\n            if (watch === undefined) {\n                throw new Error(`Missing watch attribute in ${componentname} watcher`);\n            }\n            if (handler === undefined) {\n                throw new Error(`Missing handler for watcher ${watch} in ${componentname}`);\n            }\n\n            // The state manager triggers a general \"state changed\" event at a document level. However,\n            // for the internal watchers, each component can listen to specific state changed custom events\n            // in the target element. This way we can use the native event loop wihtout colliding with other\n            // reactive instances.\n            this.target.addEventListener(watch, (event) => {\n                handler.apply(component, [event.detail]);\n            });\n        });\n\n        // Register state ready function. There's the possibility a component is registered after the initial state\n        // is loaded. For those cases we have a state promise to handle this specific state change.\n        if (component.stateReady !== undefined) {\n            this.getInitialStatePromise()\n                .then(component.stateReady.bind(component))\n                .catch(reason => {\n                    log.error(`Initial state in ${componentname} rejected due to: ${reason}`);\n                    log.error(reason);\n                });\n            return;\n        }\n\n        this.components.add(component);\n    }\n\n    /**\n    * Dispatch a change in the state.\n    *\n    * @method dispatch\n    * @param {string} actionname the action name (usually the mutation name)\n    * @param {*} param any number of params the mutaiton needs.\n    */\n    dispatch(...args) {\n        let actionname, params;\n        [actionname, ...params] = args;\n        if (this.mutations[actionname] === undefined) {\n            throw new Error(`Unkown ${actionname} mutation`);\n        }\n        const mutationfunction = this.mutations[actionname];\n        mutationfunction.apply(this.mutations, [this.statemanager, ...params]);\n    }\n};\n\nexport default Reactive;\n"],"file":"reactive.min.js"}