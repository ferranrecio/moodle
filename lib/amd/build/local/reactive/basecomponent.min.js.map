{"version":3,"sources":["../../../src/local/reactive/basecomponent.js"],"names":["BaseComponent","descriptor","element","HTMLElement","Error","reactive","selectors","events","constructor","getEvents","create","addSelectors","registerComponent","query","querySelector","newselectors","selectorname","hasOwnProperty","eventname","detail","dispatchEvent","CustomEvent","bubbles","target","file","data","Promise","resolve","reject","addEventListener","component","Templates","renderForPromise","then","html","js","replaceNodeContents","catch","error","parentNode"],"mappings":"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","sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport Templates from 'core/templates';\n\n/**\n * Reactive UI component base class.\n *\n * Each UI reactive component should extend this class to interact with a reactive state.\n *\n * @module     core/local/reactive/basecomponent\n * @package    core_course\n * @copyright  2020 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nclass BaseComponent {\n\n    /**\n     * The class constructor.\n     *\n     * The only param this method gets is a constructor with all the mandatory\n     * and optional component data. Component will receive the same descriptor\n     * as create method param.\n     *\n     * The main descriptor attributes are:\n     * - reactive {reactive}: this is mandatory reactive module to register in\n     * - element {DOMelement}: all components needs an element to anchor events\n     * - (optional) selectors {object}: an optional object to override query selectors\n     *\n     * This method will call the \"create\" method before registering the component into\n     * the reactive module. This way any component can add default selectors and events.\n     *\n     * @param {object} descriptor data to create the object.\n     */\n    constructor(descriptor) {\n\n        if (descriptor.element === undefined || !(descriptor.element instanceof HTMLElement)) {\n            throw Error(`Reactive components needs a main DOM element to dispatch events`);\n        }\n\n        if (descriptor.reactive === undefined) {\n            throw Error(`Reactive components needs a reactive module to work with`);\n        }\n\n        // Load defaults if any. getDefaults is a static methods so we need to call\n        // it throught the constructor attribute.\n        this.reactive = descriptor.reactive;\n\n        this.element = descriptor.element;\n\n        // Empty default component selectors.\n        this.selectors = {};\n\n        // Empty default evenet list from the static method.\n        this.events = this.constructor.getEvents();\n\n        // Call create function to get the component defaults.\n        this.create(descriptor);\n\n        // Overwrite the components selectors if necessary.\n        if (descriptor.selectors !== undefined) {\n            this.addSelectors(descriptor.selectors);\n        }\n\n        // The getEvents is a static method because parent components should be able to\n        // listen to any subcomponent event without the specific instance. However,\n        // for bidirectional relations between components, a non static getEvents method\n        // allows us to increase the components reusability.\n        this.getEvents = () => this.events;\n\n        // Register the component.\n        this.reactive.registerComponent(this);\n    }\n\n    /**\n     * Return the component custom event names.\n     *\n     * Component cusotm events is an important part of component reusability. This function\n     * is static because is part of the component definition and should be accessible from\n     * outsite the instances. However, values will be available at instance level in the\n     * this.events object.\n     *\n     * @returns {object} the component events.\n     */\n    static getEvents() {\n        return {};\n    }\n\n    /**\n     * Return the object default descriptor.\n     *\n     * This method can be overridden by any component to add default events,\n     * selector, name or other information to the component.\n     *\n     * @returns {object} the component defaults\n     */\n    static getDefaults() {\n        return {};\n    }\n\n    /**\n     * Get the main DOM element of this component or a subelement.\n     *\n     * @param {string} query optional subelement query\n     * @returns {element|undefined} the DOM element (if any)\n     */\n    getElement(query) {\n        if (query !== undefined) {\n            return this.element.querySelector(query);\n        }\n        return this.element;\n    }\n\n    /**\n     * Add or update the component selectors.\n     *\n     * @param {object} newselectors an object of new selectors.\n     */\n    addSelectors(newselectors) {\n        for (const selectorname in newselectors) {\n            if (newselectors.hasOwnProperty(selectorname) && typeof newselectors[selectorname] === 'string') {\n                this.selectors[selectorname] = newselectors[selectorname];\n            }\n        }\n    }\n\n    /**\n     * Return a component selector.\n     *\n     * @param {string} selectorname the selector name\n     * @return {string|undefined} the query selector\n     */\n    getSelector(selectorname) {\n        return this.selectors[selectorname];\n    }\n\n    /**\n     * Return a component specific event names.\n     *\n     * Note that not all components which triggers custom events will declare them\n     * in the \"create\" method.\n     *\n     * @return {object} and object with all the component event names.\n     */\n    getEvents() {\n        return this.events;\n    }\n\n    /**\n     * Component create function.\n     *\n     * Default init method will call \"create\" when all internal attributes are set\n     * but before the component is not yet registered in the reactive module.\n     *\n     * In this method any component can define its own defaults such as:\n     * - this.selectors {object} the default query selectors of this component.\n     * - this.events {object} a list of event names this component dispatch\n     * - extract any data form the main dom element (this.element)\n     * - set any other data the component uses\n     *\n     * @param {object} descriptor the component descriptor\n     */\n    // eslint-disable-next-line no-unused-vars\n    create(descriptor) {\n        // Components may override this method to initialize selects, events or other data.\n    }\n\n    /**\n     * Dispatch a custom event on this.element\n     *\n     * This is just a convenient method to dispatch custom events from within a component.\n     * Components are free to use an alternative function to dispatch custom\n     * events. The only restriction is that it should be dispatched on this.element\n     * and specify \"bubbles:true\" to alert any component listeners.\n     *\n     * @param {string} eventname the event name\n     * @param {*} detail event detail data\n     */\n    dispatchEvent(eventname, detail) {\n        this.element.dispatchEvent(new CustomEvent(eventname, {\n            bubbles: true,\n            detail: detail,\n        }));\n    }\n\n    /**\n     * Return the list of watchers that component has.\n     *\n     * Each watcher is represented by an object with two attributes:\n     * - watch (string) the specific state event to watch. Example 'section.visible:updated'\n     * - handler (function) the function to call when the watching state change happens\n     *\n     * Any component shoudl override this method to define their state watchers.\n     *\n     * @returns {array} array of watchers.\n     */\n    getWatchers() {\n        return [];\n    }\n\n    /**\n     * Reactive module will call this method when the state is ready.\n     *\n     * Component can override this method to update/load the component HTML or to bind\n     * listeners to HTML entities.\n     */\n    stateReady() {\n        // Components can override this method.\n    }\n\n    /**\n     * Render a new Component using a mustache file.\n     *\n     * It is important to note that this method should NOT be used for loading regular mustache files\n     * as it returns a PRomise that will only be resolved if the mustache registers a component instance.\n     *\n     * @param {element} target the DOM element that contains the component\n     * @param {string} file the component mustache file to render\n     * @param {*} data the mustache data\n     * @return {Promise} a promise of the resulting component instance\n     */\n    renderComponent(target, file, data) {\n        return new Promise((resolve, reject) => {\n            target.addEventListener('ComponentRegistration:Success', ({detail}) => {\n                resolve(detail.component);\n            });\n            target.addEventListener('ComponentRegistration:Fail', () => {\n                reject(`Registration of ${file} fails.`);\n            });\n            Templates.renderForPromise(\n                file,\n                data\n            ).then(({html, js}) => {\n                Templates.replaceNodeContents(target, html, js);\n                return true;\n            }).catch(error => {\n                reject(`Rendering of ${file} throws an error.`);\n                throw error;\n            });\n        });\n    }\n\n    /**\n     * Dispatch a component registration event to the parent node.\n     *\n     * The registration event is different from the rest of the component events because\n     * if the only way in which a component can communicate its existence to a possible parent\n     * content. Most components will be created by including a mustache file and child components\n     * must emit a registration event to the parent DOM element to alert about the registration.\n     */\n    dispatchRegistrationSuccess() {\n        // The registration event does not bubble because we just want to comunicate with the parentNode.\n        // Otherwise, any component can get multiple registrations events and could not differentiate\n        // between child components and grand child components.\n        if (this.element.parentNode === undefined) {\n            return;\n        }\n        // This custom element is camptured only by renderComponent method.\n        this.element.parentNode.dispatchEvent(new CustomEvent(\n            'ComponentRegistration:Success',\n            {\n                bubbles: false,\n                detail: {component: this},\n            }\n        ));\n    }\n\n    /**\n     * Dispatch a component registration fail event to the parent node.\n     *\n     * As dispatchRegistrationSuccess, this method will communicate the registration fail only to the\n     * parent node, in order to inform only the possible parent component.\n     */\n    dispatchRegistrationFail() {\n        if (this.element.parentNode === undefined) {\n            return;\n        }\n        // This custom element is camptured only by renderComponent method.\n        this.element.parentNode.dispatchEvent(new CustomEvent(\n            'ComponentRegistration:Fail',\n            {\n                bubbles: false,\n                detail: {component: this},\n            }\n        ));\n    }\n}\n\nexport default BaseComponent;\n"],"file":"basecomponent.min.js"}