{"version":3,"file":"templatecomponent.min.js","sources":["../../../src/local/reactive/templatecomponent.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport {applyTemplate} from 'core/local/reactive/virtualdom';\nimport BaseComponent from 'core/local/reactive/basecomponent';\nimport Notification from 'core/notification';\nimport Templates from 'core/templates';\n\nconst instances = new WeakMap();\n\n/**\n * TODO describe module templatecomponent\n *\n * @module     core/local/reactive/templatecomponent\n * @class     core/local/reactive/templatecomponent\n * @copyright  2024 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nexport default class extends BaseComponent {\n    /**\n     * The class constructor.\n     *\n     * The only param this method gets is a constructor with all the mandatory\n     * and optional component data. Component will receive the same descriptor\n     * as create method param.\n     *\n     * This method will call the \"create\" method before registering the component into\n     * the reactive module. This way any component can add default selectors and events.\n     *\n     * @param {descriptor} descriptor data to create the object.\n     */\n    constructor(descriptor) {\n        super(descriptor);\n        this.currentTemplateData = null;\n    }\n\n    /**\n     * Static method to init a template component instance.\n     *\n     * This method is used to prevent creating multiple template components\n     * for the same DOM element.\n     *\n     * @param {descriptor} descriptor data to create the object.\n     */\n    static createTemplateComponent(descriptor) {\n        if (descriptor.element === undefined || !(descriptor.element instanceof HTMLElement)) {\n            throw Error(`Missing a main DOM element to create a template component.`);\n        }\n        if (instances.has(descriptor.element)) {\n            return instances.get(descriptor.element);\n        }\n        const newInstance = new this(descriptor);\n        instances.set(descriptor.element, newInstance);\n        return newInstance;\n    }\n\n    getTemplateName() {\n        return null;\n    }\n\n    getTemplateData() {\n        return null;\n    }\n\n    async refreshTemplate() {\n        const templateName = this.getTemplateName();\n        if (!templateName) {\n            throw new Error('The getTemplateName method must return the template name.');\n        }\n        let templateData = this.getTemplateData();\n        if (templateData === null) {\n            throw new Error('The getTemplateData method must return some template data.');\n        }\n\n        // Reactive data cannot be altered outsite a mutation. However, the template library\n        // will add some new data. We need to copy all the data to a full copy before continuing.\n        // Furthermore, we also need the currentTemplateData to be a full copy to compare new values.\n        const templateDataJson = JSON.stringify(templateData);\n        templateData = JSON.parse(templateDataJson);\n\n        if (templateDataJson === JSON.stringify(this.currentTemplateData)) {\n            return;\n        }\n\n        window.console.log('Refreshing template', templateName, templateData);\n        try {\n            const {html, js} = await Templates.renderForPromise(templateName, templateData);\n            applyTemplate(this.element, html, js);\n            // Await Templates.replaceNodeContents(favouriteArea, html, js);\n            this.currentTemplateData = templateData;\n        } catch (error) {\n            Notification.exception(error);\n        }\n    }\n\n    /**\n     * Component watchers.\n     *\n     * By default, all template components will watch the state:updated event to refresh the template.\n     * However, for complex reactive applications, the rendering could be optimized by watching only\n     * the specific state properties that affect the template.\n     *\n     * @returns {Array} of watchers\n     */\n    getWatchers() {\n        return [\n            {watch: `state:updated`, handler: this.refreshTemplate},\n        ];\n    }\n}\n"],"names":["instances","WeakMap","BaseComponent","constructor","descriptor","currentTemplateData","undefined","element","HTMLElement","Error","has","get","newInstance","this","set","getTemplateName","getTemplateData","templateName","templateData","templateDataJson","JSON","stringify","parse","window","console","log","html","js","Templates","renderForPromise","error","exception","getWatchers","watch","handler","refreshTemplate"],"mappings":"6iBAoBMA,UAAY,IAAIC;;;;;;;;4BAWOC,uBAazBC,YAAYC,kBACFA,iBACDC,oBAAsB,oCAWAD,oBACAE,IAAvBF,WAAWG,WAA2BH,WAAWG,mBAAmBC,mBAC9DC,uEAENT,UAAUU,IAAIN,WAAWG,gBAClBP,UAAUW,IAAIP,WAAWG,eAE9BK,YAAc,IAAIC,KAAKT,mBAC7BJ,UAAUc,IAAIV,WAAWG,QAASK,aAC3BA,YAGXG,yBACW,KAGXC,yBACW,mCAIDC,aAAeJ,KAAKE,sBACrBE,mBACK,IAAIR,MAAM,iEAEhBS,aAAeL,KAAKG,qBACH,OAAjBE,mBACM,IAAIT,MAAM,oEAMdU,iBAAmBC,KAAKC,UAAUH,iBACxCA,aAAeE,KAAKE,MAAMH,kBAEtBA,mBAAqBC,KAAKC,UAAUR,KAAKR,sBAI7CkB,OAAOC,QAAQC,IAAI,sBAAuBR,aAAcC,wBAE9CQ,KAACA,KAADC,GAAOA,UAAYC,mBAAUC,iBAAiBZ,aAAcC,4CACpDL,KAAKN,QAASmB,KAAMC,SAE7BtB,oBAAsBa,aAC7B,MAAOY,6BACQC,UAAUD,SAa/BE,oBACW,CACH,CAACC,sBAAwBC,QAASrB,KAAKsB"}