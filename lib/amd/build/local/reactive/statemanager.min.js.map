{"version":3,"sources":["../../../src/local/reactive/statemanager.js"],"names":["StateManager","dispatchevent","target","dispatchEvent","document","readonly","eventstopublish","initialPromise","Promise","resolve","addEventListener","initialStateDone","event","detail","state","initialstate","Error","Proxy","Handler","prop","hasOwnProperty","action","_publishEvents","updates","Array","isArray","setReadOnly","forEach","update","name","processUpdate","fields","updatename","StateMap","add","current","id","get","delete","field","data","parentaction","push","eventname","eventdata","fieldChanges","sort","a","b","weights","created","updated","deleted","aweight","bweight","length","publishedevents","Set","eventkey","has","element","statemanager","proxyvalues","obj","value","receiver","JSON","stringify","loadValues","registerStateAction","iterable","key","normalizeKey","checkValue","result","valueOf","set","previous","values","newvalue","Map"],"mappings":"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","sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Reactive simple state manager.\n *\n * The state manager contains the state data, trigger update events and\n * can lock and unlock the state data.\n *\n * This file contains the three main elements of the state manager:\n * - State manager: the public class to alter the state, dispatch events and process update messages.\n * - Proxy handler: a private class to keep track of the state object changes.\n * - StateMap class: a private class extending Map class that triggers event when a state list is modifed.\n *\n * @module     core/local/reactive/statemanager\n * @package    core_course\n * @copyright  2021 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n/**\n * State manager class.\n *\n * This class handle the reactive state and ensure only valid mutations can modify the state.\n * It also provide methods to apply batch state update messages (see processUpdates function doc\n * for more details on update messages).\n *\n * Implementing a deep state manager is complex and will require many frontend resources. To keep\n * the state fast and simple, the state can ONLY store two kind of data:\n *  - Object with attributes\n *  - Sets of objects with id attributes.\n *\n * This is an example of a valid state:\n *\n * {\n *  course: {\n *      name: 'course name',\n *      shortname: 'courseshort',\n *      sectionlist: [21, 34]\n *  },\n *  sections: [\n *      {id: 21, name: 'Topic 1', visible: true},\n *      {id: 34, name: 'Topic 2', visible: false,\n *  ],\n * }\n *\n * The following cases are NOT allowed at a state ROOT level (throws an exception if they are assigned):\n *  - Simple values (strings, boolean...).\n *  - Arrays of simple values.\n *  - Array of objects without ID attribute (all arrays will be converted to maps and requires an ID).\n *\n * Thanks to those limitations it can simplify the state update messages and the event names. If You\n * need to store simple data, just group them in an object.\n *\n * To grant any state change triggers the proper events, the class uses two private structures:\n * - proxy handler: any object stored in the state is proxied using this class.\n * - StateMap class: any object set in the state will be converted to StateMap using the\n *   objects id attribute.\n */\nexport default class StateManager {\n\n    /**\n     * Create a basic reactive state store.\n     *\n     * The state manager is meant to work with native JS events. To ensure each reactive module can use\n     * it in its own way, the parent element must provide a valid event dispatcher function and an optional\n     * DOM element to anchor the event.\n     *\n     * @param {function} dispatchevent the function to dispatch the custom event when the state changes.\n     * @param {element} target the state changed custom event target (document if none provided)\n     */\n    constructor(dispatchevent, target) {\n\n        // The dispatch event function.\n        this.dispatchEvent = dispatchevent;\n        // The DOM container to trigger events.\n        this.target = target ?? document;\n        // State can be altered freely until initial state is set.\n        this.readonly = false;\n        // List of state changes pending to be published as events.\n        this.eventstopublish = [];\n\n        // The state_loaded event is special because it only happens one but all components\n        // may react to that state, even if they are registered after the setIinitialState.\n        // For these reason we use a promise for that event.\n        this.initialPromise = new Promise((resolve) => {\n            const initialStateDone = (event) => {\n                resolve(event.detail.state);\n            };\n            this.target.addEventListener('state:loaded', initialStateDone);\n        });\n    }\n\n    /**\n     * Loads the initial state.\n     *\n     * Note this method will trigger a state changed event with \"state:loaded\" actionname.\n     *\n     * The state mode will be set to read only when the initial state is loaded.\n     *\n     * @param {object} initialstate\n     */\n    setInitialState(initialstate) {\n\n        if (this.state !== undefined) {\n            throw Error('Initial state can only be initialized ones');\n        }\n\n        // Create the state object.\n        let state = new Proxy({}, new Handler('state', this, true));\n        for (const prop in initialstate) {\n            if (initialstate.hasOwnProperty(prop)) {\n                state[prop] = initialstate[prop];\n            }\n        }\n        this.state = state;\n\n        // When the state is loaded we can lock it to prevent illegal changes.\n        this.readonly = true;\n\n        this.dispatchEvent({\n            action: 'state:loaded',\n            state: this.state,\n        }, this.target);\n    }\n\n    /**\n     * Generate a promise that will be resolved when the initial state is loaded.\n     *\n     * In most cases the final state will be loaded using an ajax call. This is the reason\n     * why states manager are created unlocked and won't be reactive until the initial state is set.\n     *\n     * @return {Promise} the resulting promise\n     */\n    getInitialPromise() {\n        return this.initialPromise;\n    }\n\n    /**\n     * Locks or unlocks the state to prevent illegal updates.\n     *\n     * Mutations use this method to modify the state. Once the state is updated, they must\n     * block again the state.\n     *\n     * All changes done while the state is writable will be registered using registerStateAction.\n     * When the state is set again to read only the method will trigger _publishEvents to communicate\n     * changes to all watchers.\n     *\n     * @param {bool} readonly if the state is in read only mode enabled\n     */\n    setReadOnly(readonly) {\n\n        this.readonly = readonly;\n\n        // When the state is in readonly again is time to publish all pending events.\n        if (this.readonly) {\n            this._publishEvents();\n        }\n    }\n\n    /**\n     * Process a state updates array and do all the necessary changes.\n     *\n     * Note this method unlocks the state while it is executing and relocks it\n     * when finishes.\n     *\n     * @param {array} updates\n     */\n    processUpdates(updates) {\n        if (!Array.isArray(updates)) {\n            throw Error('State updates must be an array');\n        }\n        this.setReadOnly(false);\n        updates.forEach((update) => {\n            if (update.name === undefined) {\n                throw Error('Missing state update name');\n            }\n            this.processUpdate(\n                update.name, update.action, update.fields\n            );\n        });\n        this.setReadOnly(true);\n    }\n\n    /**\n     * Process a single state update.\n     *\n     * Note this method will not lock or unlock the state by itself.\n     *\n     * @param {string} updatename\n     * @param {string} action\n     * @param {object} fields\n     */\n    processUpdate(updatename, action, fields) {\n\n        let state = this.state;\n\n        if (!fields) {\n            throw Error('Missing state update fields');\n        }\n\n        // Process creation.\n        if (action == 'create') {\n            // Create can be applied only to lists, not to objects.\n            if (state[updatename] instanceof StateMap) {\n                state[updatename].add(fields);\n                return;\n            }\n            state[updatename] = fields;\n            return;\n        }\n\n        // Get the current value.\n        let current = state[updatename];\n        if (current instanceof StateMap) {\n            if (fields.id === undefined) {\n                throw Error(`Missing id for ${updatename} state update`);\n            }\n            current = state[updatename].get(fields.id);\n            if (!current) {\n                throw Error(`Inexistent ${updatename} ${fields.id}`);\n            }\n        }\n\n        // Unlock the state to do some changes.\n        this.readonly = false;\n\n        // Process deletion.\n        if (action == 'delete') {\n            if (state[updatename] instanceof StateMap) {\n                state[updatename].delete(fields.id);\n                return;\n            }\n            delete state[updatename];\n            return;\n        }\n\n        // Execute updates.\n        if (action == 'update' || action === undefined) {\n            for (const prop in fields) {\n                if (fields.hasOwnProperty(prop)) {\n                    current[prop] = fields[prop];\n                }\n            }\n            return;\n        }\n    }\n\n    /**\n     * Register a state modification and generate the necessary events.\n     *\n     * This method is used mainly by proxy helpers to dispatch state change event.\n     * However, mutations can use it to inform components about non reactive changes\n     * in the state (only the two first levels of the state are reactive).\n     *\n     * Each action can produce several events:\n     * - The specific attribute updated, created or deleter (example: \"cm.visible:updated\")\n     * - The general state object updated, created or deleted (example: \"cm:updated\")\n     * - If the element has an ID attribute, the specific event with id (example: \"cm[42].visible:updated\")\n     * - If the element has an ID attribute, the general event with id (example: \"cm[42]:updated\")\n     * - A generic state update event \"state:update\"\n     *\n     * @param {string} field the affected state field name\n     * @param {string|null} prop the affecter field property (null if affect the full object)\n     * @param {string} action the action done (created/updated/deleted)\n     * @param {*} data the affected data\n     */\n    registerStateAction(field, prop, action, data) {\n\n        let parentaction = 'updated';\n\n        if (prop !== null) {\n            this.eventstopublish.push({\n                eventname: `${field}.${prop}:${action}`,\n                eventdata: data,\n                action,\n            });\n        } else {\n            parentaction = action;\n        }\n\n        // Trigger extra events if the element has an ID attribute.\n        if (data.id !== undefined) {\n            if (prop !== null) {\n                this.eventstopublish.push({\n                    eventname: `${field}[${data.id}].${prop}:${action}`,\n                    eventdata: data,\n                    action,\n                });\n            }\n            this.eventstopublish.push({\n                eventname: `${field}[${data.id}]:${parentaction}`,\n                eventdata: data,\n                action: parentaction,\n            });\n        }\n\n        // Register the general change.\n        this.eventstopublish.push({\n            eventname: `${field}:${parentaction}`,\n            eventdata: data,\n            action: parentaction,\n        });\n\n        // Register state updated event.\n        this.eventstopublish.push({\n            eventname: `state:updated`,\n            eventdata: data,\n            action: 'updated',\n        });\n    }\n\n    /**\n     * Internal method to publish events.\n     *\n     * This is a private method, it will be invoked when the state is set back to read only mode.\n     */\n    _publishEvents() {\n        const fieldChanges = this.eventstopublish;\n        this.eventstopublish = [];\n\n        // State changes can be registered in any order. However it will avoid many\n        // components errors if they are sorted to have creations-updates-deletes in case\n        // some component needs to create or destroy DOM elements before updating them.\n        fieldChanges.sort((a, b) => {\n            const weights = {\n                created: 0,\n                updated: 1,\n                deleted: 2,\n            };\n            const aweight = weights[a.action] ?? 0;\n            const bweight = weights[b.action] ?? 0;\n            // In case both have the same weight, the eventname length decide.\n            if (aweight === bweight) {\n                return a.eventname.length - b.eventname.length;\n            }\n            return aweight - bweight;\n        });\n\n        // List of the published events to prevent redundancies.\n        let publishedevents = new Set();\n\n        fieldChanges.forEach((event) => {\n\n            const eventkey = `${event.eventname}.${event.eventdata.id ?? 0}`;\n\n            if (!publishedevents.has(eventkey)) {\n                this.dispatchEvent({\n                    action: event.eventname,\n                    state: this.state,\n                    element: event.eventdata\n                }, this.target);\n                // PubSub.publish(event.eventname, {state, element: event.eventdata});\n                publishedevents.add(eventkey);\n            }\n        });\n    }\n}\n\n// Proxy helpers.\n\n/**\n * The proxy handler.\n *\n * This class will inform any value change directly to the state manager.\n *\n * The proxied variable will throw an error if it is altered when the state manager is\n * in read only mode.\n */\nclass Handler {\n\n    /**\n     * Class constructor.\n     *\n     * @param {string} name the variable name used for identify triggered actions\n     * @param {StateManager} statemanager the state manager object\n     * @param {boolean} proxyvalues if new values must be proxied (used only at state root level)\n     */\n    constructor(name, statemanager, proxyvalues) {\n        this.name = name;\n        this.statemanager = statemanager;\n        this.proxyvalues = proxyvalues ?? false;\n    }\n\n    /**\n     * Set trap to trigger events when the state changes.\n     *\n     * @param {object} obj the source object (not proxied)\n     * @param {string} prop the attribute to set\n     * @param {*} value the value to save\n     * @param {*} receiver the proxied element to be attached to events\n     * @returns {boolean} if the value is set\n     */\n    set(obj, prop, value, receiver) {\n\n        // Only mutations should be able to set state values.\n        if (this.statemanager.readonly) {\n            throw new Error(`State locked. Use mutations to change ${prop} value in ${this.name}.`);\n        }\n\n        // Check any data change.\n        if (JSON.stringify(obj[prop]) === JSON.stringify(value)) {\n            return true;\n        }\n\n        const action = (obj[prop] !== undefined) ? 'updated' : 'created';\n\n        // Proxy value if necessary (used at state root level).\n        if (this.proxyvalues) {\n            if (Array.isArray(value)) {\n                obj[prop] = new StateMap(prop, this.statemanager).loadValues(value);\n            } else {\n                obj[prop] = new Proxy(value, new Handler(prop, this.statemanager));\n            }\n        } else {\n            obj[prop] = value;\n        }\n\n        // If the state is not ready yet means the initial state is not yet loaded.\n        if (this.statemanager.state === undefined) {\n            return true;\n        }\n\n        this.statemanager.registerStateAction(this.name, prop, action, receiver);\n\n        return true;\n    }\n\n    /**\n     * Delete property trap to trigger state change events.\n     *\n     * @param {*} obj the affected object (not proxied)\n     * @param {*} prop the prop to delete\n     * @returns {boolean} if prop is deleted\n     */\n    deleteProperty(obj, prop) {\n        // Only mutations should be able to set state values.\n        if (this.statemanager.readonly) {\n            throw new Error(`State locked. Use mutations to delete ${prop} in ${this.name}.`);\n        }\n        if (prop in obj) {\n\n            delete obj[prop];\n\n            this.statemanager.registerStateAction(this.name, prop, 'deleted', obj);\n        }\n        return true;\n    }\n}\n\n/**\n * Class to add events dispatching to the JS Map class.\n *\n * When the state has a list of objects (with IDs) it will be converted into a StateMap.\n * StateMap is used almost in the same way as a regular JS map. Because all elements have an\n * id attribute, it has some specific methods:\n *  - add: a convenient method to add an element without specifying the key (\"id\" attribute will be used as a key).\n *  - loadValues: to add many elements at once wihout specifying keys (\"id\" attribute will be used).\n *\n * Apart, the main difference between regular Map and MapState is that this one will inform any change to the\n * state manager.\n */\nclass StateMap extends Map {\n\n    /**\n     * Create a reactive Map.\n     *\n     * @param {string} name the property name\n     * @param {StateManager} statemanager the state manager\n     * @param {iterable} iterable an iterable object to create the Map\n     */\n    constructor(name, statemanager, iterable) {\n        // We don't have any \"this\" until be call super.\n        super(iterable);\n        this.name = name;\n        this.statemanager = statemanager;\n    }\n\n    /**\n     * Set an element into the map.\n     *\n     * Each value needs it's own id attribute. Objects without id will be rejected.\n     * The function will throw an error if the value id and the key are not the same.\n     *\n     * @param {*} key the key to store\n     * @param {*} value the value to store\n     * @returns {Map} the resulting Map object\n     */\n    set(key, value) {\n\n        // Only mutations should be able to set state values.\n        if (this.statemanager.readonly) {\n            throw new Error(`State locked. Use mutations to change ${key} value in ${this.name}.`);\n        }\n\n        // Normalize keys as string to prevent json decoding errors.\n        key = this.normalizeKey(key);\n\n        this.checkValue(value);\n\n        if (key === undefined || key === null) {\n            throw Error('State lists keys cannot be null or undefined');\n        }\n\n        // ID is mandatory and should be the same as the key.\n        if (value.id !== key) {\n            throw new Error(`State error: ${this.name} list element ID (${value.id}) and key (${key}) mismatch`);\n        }\n\n        const action = (super.has(key)) ? 'updated' : 'created';\n\n        // Save proxied data into the list.\n        const result = super.set(key, new Proxy(value, new Handler(this.name, this.statemanager)));\n\n        // If the state is not ready yet means the initial state is not yet loaded.\n        if (this.statemanager.state === undefined) {\n            return result;\n        }\n\n        this.statemanager.registerStateAction(this.name, null, action, super.get(key));\n\n        return result;\n    }\n\n    /**\n     * Check if a value is valid to be stored in a a State List.\n     *\n     * Only objects with id attribute can be stored in State lists.\n     *\n     * This method throws an error if the value is not valid.\n     *\n     * @param {object} value (with ID)\n     */\n    checkValue(value) {\n        if (!typeof value === 'object' && value !== null) {\n            throw Error('State lists can contain objects only');\n        }\n\n        if (value.id === undefined) {\n            throw Error('State lists elements must contain at least an id attribute');\n        }\n    }\n\n    /**\n     * Return a normalized key value for state map.\n     *\n     * Regular maps uses strict key comparissons but state maps are indexed by ID.JSON conversions\n     * and webservices sometimes do unexpected types conversions so we convert any integer key to string.\n     *\n     * @param {*} key the provided key\n     * @returns {string}\n     */\n    normalizeKey(key) {\n        return String(key).valueOf();\n    }\n\n    /**\n     * Insert a new element int a list.\n     *\n     * Each value needs it's own id attribute. Objects withouts id will be rejected.\n     *\n     * @param {object} value the value to add (needs an id attribute)\n     * @returns {Map} the resulting Map object\n     */\n    add(value) {\n        this.checkValue(value);\n        return this.set(value.id, value);\n    }\n\n    /**\n     * Return a state map element.\n     *\n     * @param {*} key the element id\n     * @return {Object}\n     */\n    get(key) {\n        return super.get(this.normalizeKey(key));\n    }\n\n    /**\n     * Check whether an element with the specified key exists or not.\n     *\n     * @param {*} key the key to find\n     * @return {boolean}\n     */\n    has(key) {\n        return super.has(this.normalizeKey(key));\n    }\n\n    /**\n     * Delete an element from the map.\n     *\n     * @param {*} key\n     * @returns {boolean}\n     */\n    delete(key) {\n        // State maps uses only string keys to avoid strict comparisons.\n        key = this.normalizeKey(key);\n\n        // Only mutations should be able to set state values.\n        if (this.statemanager.readonly) {\n            throw new Error(`State locked. Use mutations to change ${key} value in ${this.name}.`);\n        }\n\n        const previous = super.get(key);\n\n        const result = super.delete(key);\n        if (!result) {\n            return result;\n        }\n\n        this.statemanager.registerStateAction(this.name, null, 'deleted', previous);\n\n        return result;\n    }\n\n    /**\n     * Return a suitable structure for JSON conversion.\n     *\n     * This function is needed because new values are compared in JSON. StateMap has Private\n     * attributes which cannot be stringified (like this.statemanager which will produce an\n     * infinite recursivity).\n     *\n     * @returns {array}\n     */\n    toJSON() {\n        let result = [];\n        this.forEach((value) => {\n            result.push(value);\n        });\n        return result;\n    }\n\n    /**\n     * Insert a full list of values using the id attributes as keys.\n     *\n     * This method is used mainly to initialize the list. Note each element is indexed by its \"id\" attribute.\n     * This is a basic restriction of StateMap. All elements need an id attribute, otherwise it won't be saved.\n     *\n     * @param {iterable} values the values to load\n     * @returns {StateMap} return the this value\n     */\n    loadValues(values) {\n        values.forEach((data) => {\n            this.checkValue(data);\n            let key = data.id;\n            let newvalue = new Proxy(data, new Handler(this.name, this.statemanager));\n            this.set(key, newvalue);\n        });\n        return this;\n    }\n}\n"],"file":"statemanager.min.js"}