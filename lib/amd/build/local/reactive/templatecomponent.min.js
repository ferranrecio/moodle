define("core/local/reactive/templatecomponent",["exports","core/local/reactive/virtualdom","core/local/reactive/basecomponent","core/local/reactive/weightedqueue","core/notification","core/templates"],(function(_exports,_virtualdom,_basecomponent,_weightedqueue,_notification,_templates){function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}Object.defineProperty(_exports,"__esModule",{value:!0}),_exports.default=void 0,_virtualdom=_interopRequireDefault(_virtualdom),_basecomponent=_interopRequireDefault(_basecomponent),_weightedqueue=_interopRequireDefault(_weightedqueue),_notification=_interopRequireDefault(_notification),_templates=_interopRequireDefault(_templates);const instances=new WeakMap,renderQueue=new _weightedqueue.default;
/**
   * Template component base class.
   *
   * A template component is a reactive component that uses virtual DOM to refresh the
   * template when the state is updated.
   *
   * @module     core/local/reactive/templatecomponent
   * @class     core/local/reactive/templatecomponent
   * @copyright  2024 Ferran Recio <ferran@moodle.com>
   * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
class _default extends _basecomponent.default{constructor(descriptor){if(super(descriptor),!descriptor.selector)throw new Error("Template reactive components need a main selector ("+this.name+").");this.currentTemplateData=null,this.renderPriority=this.calculateRenderPriority(),this.refreshPending=!1,_virtualdom.default.cleanDomElement(this.element)}static createTemplateComponent(selector,reactive,otherSelectors){if(void 0===selector)throw Error("Missing a main DOM selector to create a template component.");const descriptor={selector:selector,element:document.querySelector(selector),reactive:reactive,selectors:otherSelectors};if(!descriptor.element)throw Error("Main template element not found for selector ".concat(descriptor.selector,"."));if(instances.has(descriptor.element))return instances.get(descriptor.element);const newInstance=new this(descriptor);return instances.set(descriptor.element,newInstance),newInstance}getElementComponent(element){return instances.get(element)}getTemplateName(){}getTemplateData(){}allowTemplateInjection(){return!1}refreshTemplate(){this.refreshPending||(this.refreshPending=!0,renderQueue.add(this._executeRefreshTemplate.bind(this),this.renderPriority),renderQueue.executeDebounce())}async _executeRefreshTemplate(){this.refreshPending&&(this.refreshPending=!1,this.element.isConnected?await this._reloadTemplateIfNeeded():this.reactive.unregisterComponent(this))}injectContent(newContent){this.allowTemplateInjection()&&(_virtualdom.default.applyHTMLElement(this,newContent),this.refreshPending=!1)}async _reloadTemplateIfNeeded(){let templateData=this.getTemplateData();if(void 0===templateData)return;if(null===templateData)return void this.reactive.unregisterComponent(this);const templateDataJson=JSON.stringify(templateData);if(templateData=JSON.parse(templateDataJson),templateDataJson===JSON.stringify(this.currentTemplateData))return;const templateName=this.getTemplateName();if(!templateName)throw new Error("Method getTemplateName must return the template name ("+this.name+").");try{const{html:html,js:js}=await _templates.default.renderForPromise(templateName,templateData);_virtualdom.default.applyTemplate(this,html,js),this.currentTemplateData=templateData}catch(error){_notification.default.exception(error)}}calculateRenderPriority(){if(!this.allowTemplateInjection())return 0;let priority=0,parent=this.element.parentElement;for(;parent;)parent.getAttribute("data-mdl-component-hash")&&priority++,parent=parent.parentElement;return priority}getWatchers(){return[{watch:"state:updated",handler:this.refreshTemplate}]}}return _exports.default=_default,_exports.default}));

//# sourceMappingURL=templatecomponent.min.js.map