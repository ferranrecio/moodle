define("core/local/reactive/templatecomponent",["exports","core/local/reactive/virtualdom","core/local/reactive/basecomponent","core/local/reactive/weightedqueue","core/notification","core/templates"],(function(_exports,_virtualdom,_basecomponent,_weightedqueue,_notification,_templates){function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}Object.defineProperty(_exports,"__esModule",{value:!0}),_exports.default=void 0,_virtualdom=_interopRequireDefault(_virtualdom),_basecomponent=_interopRequireDefault(_basecomponent),_weightedqueue=_interopRequireDefault(_weightedqueue),_notification=_interopRequireDefault(_notification),_templates=_interopRequireDefault(_templates);const instances=new WeakMap,renderQueue=new _weightedqueue.default;
/**
   * Template component base class.
   *
   * A template component is a reactive component that uses virtual DOM to refresh the
   * template when the state is updated.
   *
   * @module     core/local/reactive/templatecomponent
   * @class     core/local/reactive/templatecomponent
   * @copyright  2024 Ferran Recio <ferran@moodle.com>
   * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
class _default extends _basecomponent.default{constructor(descriptor){super(descriptor),this.currentTemplateData=null,this.renderPriority=this.calculateRenderPriority(),this.injectedTemplateContent=null}static createTemplateComponent(descriptor){if(void 0===descriptor.element||!(descriptor.element instanceof HTMLElement))throw Error("Missing a main DOM element to create a template component.");if(instances.has(descriptor.element))return instances.get(descriptor.element);const newInstance=new this(descriptor);return instances.set(descriptor.element,newInstance),newInstance}getElementComponent(element){return instances.get(element)}getTemplateName(){}getTemplateData(){}allowTemplateInjection(){return!1}refreshTemplate(){renderQueue.add(this._executeRefreshTemplate.bind(this),this.renderPriority),renderQueue.executeDebounce()}async _executeRefreshTemplate(){if(this.element.isConnected)return null!==this.injectedTemplateContent?(_virtualdom.default.applyHTMLElement(this,this.injectedTemplateContent),void(this.injectedTemplateContent=null)):void await this._reloadTemplateIfNeeded();this.reactive.unregisterComponent(this)}injectContent(newContent){this.allowTemplateInjection()&&(this.injectedTemplateContent=newContent)}async _reloadTemplateIfNeeded(){let templateData=this.getTemplateData();if(void 0===templateData&&this.allowTemplateInjection())return void this.reactive.unregisterComponent(this);var _ref;if(void 0===templateData)throw new Error(null!==(_ref="Method getTemplateData must return the template data, or null to remove  ("+this.name)&&void 0!==_ref?_ref:"unkown).");if(null===templateData)return void this.reactive.unregisterComponent(this);const templateDataJson=JSON.stringify(templateData);if(templateData=JSON.parse(templateDataJson),templateDataJson===JSON.stringify(this.currentTemplateData))return;const templateName=this.getTemplateName();var _ref2;if(!templateName)throw new Error(null!==(_ref2="Method getTemplateName must return the template name ("+this.name)&&void 0!==_ref2?_ref2:"unkown).");try{const{html:html,js:js}=await _templates.default.renderForPromise(templateName,templateData);_virtualdom.default.applyTemplate(this,html,js),this.currentTemplateData=templateData}catch(error){_notification.default.exception(error)}}calculateRenderPriority(){if(!this.allowTemplateInjection())return 0;let priority=0,parent=this.element.parentElement;for(;parent;)parent.getAttribute("data-mdl-component-hash")&&priority++,parent=parent.parentElement;return priority}getWatchers(){return[{watch:"state:updated",handler:this.refreshTemplate}]}}return _exports.default=_default,_exports.default}));

//# sourceMappingURL=templatecomponent.min.js.map