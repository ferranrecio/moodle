{"version":3,"file":"virtualdom.min.js","sources":["../../../src/local/reactive/virtualdom.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport Templates from 'core/templates';\n\n/**\n * @typedef {import('./templatecomponent')} TemplateComponent\n */\n\n/**\n * Attributes that are protected from being removed.\n * @type {Array}\n */\nconst protectecAttributes = [\n    'data-mdl-component-hash',\n    'data-mdl-refresh'\n];\n\n/**\n * Basic VirtualDOM differ for reactive components.\n *\n * This code is loosely based on the following articles:\n * https://dev.to/joydeep-bhowmik/virtual-dom-diffing-algorithm-implementation-in-vanilla-javascript-2324\n * https://dev.to/joydeep-bhowmik/adding-keys-our-dom-diffing-algorithm-4d7g\n *\n * @module     core/local/reactive/virtualdom\n * @copyright  2024 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nexport default class {\n\n    /**\n     * The constructor.\n     *\n     * @private\n     * @param {TemplateComponent} component\n     */\n    constructor(component) {\n        this.component = component;\n        this.keyIndex = null;\n    }\n\n    /**\n     * Static method to apply the template to a component.\n     *\n     * @param {TemplateComponent} component the reactive component\n     * @param {String} html\n     * @param {String} js\n     */\n    static applyTemplate(component, html, js) {\n        const virtualDom = new this(component);\n        virtualDom._applyVirtualDomFromTemplate(html, js);\n    }\n\n    /**\n     * Static method to apply a virtual dom element to a component.\n     *\n     * @param {TemplateComponent} component the reactive component\n     * @param {HTMLElement} vdom the virtual dom element\n     */\n    static applyHTMLElement(component, vdom) {\n        const virtualDom = new this(component);\n        virtualDom._applyVirtualDomFromElement(vdom);\n    }\n\n    /**\n     * Clean the component dom.\n     *\n     * The method will remove any comment or empty text node from the element.\n     *\n     * @param {HTMLElement} element\n     */\n    static cleanDomElement(element) {\n        const virtualDom = new this();\n        virtualDom.clean(element);\n    }\n\n    /**\n     * Apply the virtual dom to the component from a loaded template.\n     *\n     * @private\n     * @param {String} newContent the new content\n     * @param {String} [newJs] the new js\n     */\n    _applyVirtualDomFromTemplate(newContent, newJs) {\n        const vdom = this._parseHTML(newContent);\n        this._applyVirtualDomFromElement(vdom);\n        if (newJs !== undefined) {\n            Templates.runTemplateJS(newJs);\n        }\n    }\n\n    /**\n     * Scan all key elements present in the virtual dom and return the list of the dom ones.\n     *\n     * @private\n     * @param {HTMLElement} vdom the virtual dom element\n     * @param {HTMLElement} dom the real dom element\n     * @returns {Map}\n     */\n    _getKeyElementsIndex(vdom, dom) {\n        const result = new Map();\n        const elementsWithDataMdlKey = vdom.querySelectorAll('[data-mdl-key]');\n        elementsWithDataMdlKey.forEach(element => {\n            const key = element.getAttribute('data-mdl-key');\n            const domElement = dom.querySelector(`[data-mdl-key=\"${key}\"]`);\n            if (!domElement) {\n                return;\n            }\n            // Subcomponents can have the same keys as the parent. We ignore any key that is not part of this component.\n            const parentComponent = domElement.closest('[data-mdl-component-hash]');\n            if (parentComponent.getAttribute('data-mdl-component-hash') != this.component.getComponentHash()) {\n                return;\n            }\n            result.set(key, domElement);\n        });\n        return result;\n    }\n\n    /**\n     * Apply the virtual dom to the component from an virtual dom element.\n     *\n     * @private\n     * @param {HTMLElement} vdom the element to diff\n     */\n    _applyVirtualDomFromElement(vdom) {\n        const dom = this.component.getElement();\n        this.keyIndex = this._getKeyElementsIndex(vdom, dom);\n        this._diff(vdom, dom);\n        this._cleanMismatchedComponents(dom);\n    }\n\n    /**\n     * Execute a diff.\n     *\n     * @private\n     * @param {HTMLElement} vdom virtual dom element\n     * @param {HTMLElement} dom real dom element\n     */\n    _diff(vdom, dom) {\n        if (!this._needsToDiffed(vdom, dom)) {\n            return;\n        }\n        // If dom has no childs then append the childs from vdom.\n        if (dom.hasChildNodes() === false && vdom.hasChildNodes() === true) {\n            for (let i = 0; i < vdom.childNodes.length; i++) {\n                dom.append(vdom.childNodes[i].cloneNode(true));\n            }\n            return;\n        }\n\n        this._diffChilds(vdom, dom);\n    }\n\n    /**\n     * Validate if the element needs to be diffed.\n     *\n     * @private\n     * @param {HTMLElement} vdom virtual dom element\n     * @param {HTMLElement} dom real dom element\n     * @returns\n     */\n    _needsToDiffed(vdom, dom) {\n        if (dom.getAttribute('data-mdl-refresh') === 'static') {\n            return false;\n        }\n        if (dom.getAttribute('data-mdl-refresh') === 'inject') {\n            return true;\n        }\n\n        if (this._injectContentToElementComponent(vdom, dom) === true) {\n            // The subcomponent will take care of the diff for us.\n            return false;\n        }\n\n        if (vdom.isEqualNode(dom)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Try to inject the content into an element component, if any.\n     *\n     * When injecting the content, the subcomponent will be responsible for the diffing\n     * and the diff can stop at this point.\n     *\n     * @private\n     * @param {HTMLElement} vdom\n     * @param {HTMLElement} dom\n     * @returns {Boolean} if the content was injected or not.\n     */\n    _injectContentToElementComponent(vdom, dom) {\n        if (\n            !dom.hasAttribute('data-mdl-component-hash') ||\n            dom.getAttribute('data-mdl-component-hash') === this.component.getComponentHash()\n        ) {\n            return false;\n        }\n\n        const subcomponent = this.component.getElementComponent(dom);\n        if (!subcomponent) {\n            return false;\n        }\n\n        // Each template component has it's unique selector (mandatory for creation),\n        // if it does not match means that the component is not the same.\n        const componentSelector = subcomponent.getMainSelector();\n        if (!componentSelector || !vdom.matches(componentSelector)) {\n            // Add a mark into the element so we can remove the hash\n            // if not processed at the end of the diff.\n            dom.addAtribute('data-mdl-vrdom-component-clean', 'true');\n            return false;\n        }\n\n        if (subcomponent && subcomponent.allowTemplateInjection()) {\n            dom.removeAttribute('data-mdl-vrdom-component-clean');\n            subcomponent.injectContent(vdom);\n        }\n        return true;\n    }\n\n    /**\n     * Forces refreshing components that do not match their selector.\n     *\n     * This method is called at the end of the full diff to force instantiate new\n     * components if the component selector does not match for some reason.\n     *\n     * @param {HTMLElement} dom\n     */\n    _cleanMismatchedComponents(dom) {\n        const elements = dom.querySelectorAll('[data-mdl-vrdom-component-clean]');\n        elements.forEach(element => {\n            element.removeAttribute('data-mdl-component-hash');\n            element.removeAttribute('data-mdl-vrdom-component-clean');\n        });\n    }\n\n    /**\n     * Move all child elements with data-mdl-key attribute to the same position as the vdom.\n     *\n     * @private\n     * @param {HTMLElement} vdom virtual dom element\n     * @param {HTMLElement} dom real dom element\n     */\n    _sortChildKeyElements(vdom, dom) {\n        if (vdom.querySelector(':scope > [data-mdl-key]') === null) {\n            return;\n        }\n        for (let i = 0; i < vdom.childNodes.length; i++) {\n            const key = vdom.childNodes[i].getAttribute('data-mdl-key');\n            if (!key || !this.keyIndex.has(key)) {\n                continue;\n            }\n            const newElement = this.keyIndex.get(key);\n            if (dom.childNodes[i] === newElement) {\n                continue;\n            }\n            dom.insertBefore(newElement, dom.childNodes[i]);\n        }\n    }\n\n    /**\n     * Remove all unnecessary childs from the dom before the diff.\n     *\n     * @private\n     * @param {HTMLElement} vdom virtual dom element\n     * @param {HTMLElement} dom real dom element\n     */\n    _removeUnnecessaryChilds(vdom, dom) {\n        if (dom.childNodes.length <= vdom.childNodes.length) {\n            return;\n        }\n        let count = dom.childNodes.length - vdom.childNodes.length;\n        for (; count > 0; count--) {\n            dom.lastChild.remove();\n        }\n    }\n\n    /**\n     * Diff all childs.\n     *\n     * @private\n     * @param {HTMLElement} vdom virtual dom element\n     * @param {HTMLElement} dom real dom element\n     */\n    _diffChilds(vdom, dom) {\n        this._sortChildKeyElements(vdom, dom);\n        this._removeUnnecessaryChilds(vdom, dom);\n        for (let i = 0; i < vdom.childNodes.length; i++) {\n            if (dom.childNodes[i] === undefined) {\n                dom.append(vdom.childNodes[i].cloneNode(true));\n            } else {\n                this._diffElement(vdom.childNodes[i], dom.childNodes[i]);\n            }\n            if (vdom.childNodes[i].nodeType !== Node.TEXT_NODE) {\n                this._diff(vdom.childNodes[i], dom.childNodes[i]);\n            }\n        }\n    }\n\n    /**\n     * Diff a single element.\n     *\n     * @private\n     * @param {HTMLElement} vdomNode\n     * @param {HTMLElement} domNode\n     */\n    _diffElement(vdomNode, domNode) {\n        if (this._getNodeType(vdomNode) !== this._getNodeType(domNode)) {\n            domNode.replaceWith(vdomNode.cloneNode(true));\n            return;\n        }\n\n        if (vdomNode.nodeType === Node.TEXT_NODE) {\n            if (vdomNode.textContent !== domNode.textContent) {\n                domNode.textContent = vdomNode.textContent;\n            }\n        } else {\n            this._patchAttributes(vdomNode, domNode);\n        }\n    }\n\n    /**\n     * Return the node type.\n     *\n     * @private\n     * @param {HTMLElement} node\n     * @returns {String}\n     */\n    _getNodeType(node) {\n        if (node.nodeType == Node.ELEMENT_NODE) {\n            return node.tagName.toLowerCase();\n        }\n        return node.nodeType;\n    }\n\n    /**\n     * Create an index of the attributes of the element.\n     *\n     * @private\n     * @param {HTMLElement} vdom the virtual dom element\n     * @param {HTMLElement} dom the real dom element\n     */\n    _patchAttributes(vdom, dom) {\n        let vdomAttributes = this._attributesIndex(vdom);\n        let domAttributes = this._attributesIndex(dom);\n        if (vdomAttributes == domAttributes) {\n            return;\n        }\n        Object.keys(vdomAttributes).forEach(key => {\n            this._updateAttribute(dom, key, vdomAttributes[key]);\n        });\n        Object.keys(domAttributes).forEach(key => {\n            if (vdomAttributes[key] === undefined) {\n                this._removeAttribute(dom, key);\n            }\n        });\n    }\n\n    /**\n     * Set the attribute to the element if allowed to.\n     *\n     * @param {HTMLElement} dom\n     * @param {String} name\n     * @param {String} value\n     */\n    _updateAttribute(dom, name, value) {\n        if (dom.hasAttribute(name) && dom.getAttribute(name) === value) {\n            return;\n        }\n        if (!this._canUpdateAttribute(dom, name)) {\n            return;\n        }\n        dom.setAttribute(name, value);\n    }\n\n    /**\n     * Remove the attribute from the element if allowed to.\n     *\n     * @param {HTMLElement} dom\n     * @param {HTMLElement} name\n     * @returns\n     */\n    _removeAttribute(dom, name) {\n        if (!dom.hasAttribute(name)) {\n            return;\n        }\n        if (!this._canUpdateAttribute(dom, name)) {\n            return;\n        }\n        dom.removeAttribute(name);\n    }\n\n    /**\n     * Check if the attribute can be updated.\n     *\n     * @param {HTMLElement} dom\n     * @param {String} name\n     */\n    _canUpdateAttribute(dom, name) {\n        if (protectecAttributes.includes(name)) {\n            return false;\n        }\n        if (this._isEditableFormElement(dom)) {\n            // We don't want to lose the user input when refreshing the template,\n            // unless the temaplte explicitly asks for using data-mdl-refresh=\"inject\".\n            if (dom.closest('[data-mdl-refresh=\"inject\"]')) {\n                return true;\n            }\n            return name !== 'value' && name !== 'checked' && name !== 'selected';\n        }\n        return true;\n    }\n\n    /**\n     * Check if the element is a form element the user can edit or select.\n     *\n     * @param {HTMLElement} dom\n     * @returns\n     */\n    _isEditableFormElement(dom) {\n        return dom.tagName === 'INPUT' ||\n            dom.tagName === 'TEXTAREA' ||\n            dom.tagName === 'SELECT' ||\n            dom.tagName === 'OPTION';\n    }\n\n    /**\n     * Create an index of the attributes of the element.\n     *\n     * @private\n     * @param {HTMLElement} element\n     */\n    _attributesIndex(element) {\n        var attributes = {};\n        if (element.attributes == undefined) {\n            return attributes;\n        }\n        for (var i = 0, atts = element.attributes, n = atts.length; i < n; i++) {\n            attributes[atts[i].name] = atts[i].value;\n        }\n        return attributes;\n    }\n\n    /**\n     * Parse the html string and return the main element.\n     *\n     * @private\n     * @param {String} html\n     * @returns {HTMLElement}\n     */\n    _parseHTML(html) {\n        let parser = new DOMParser();\n        let doc = parser.parseFromString(html, 'text/html');\n\n        this.clean(doc.body);\n\n        if (doc.body.childElementCount != 1) {\n            throw new Error('The HTML must have only one root element');\n        }\n\n        return doc.body.firstChild;\n    }\n\n    /**\n     * Clean the node from comments and empty text nodes.\n     *\n     * @private\n     * @param {Node} node\n     */\n    clean(node) {\n        for (let n = 0; n < node.childNodes.length; n++) {\n            const child = node.childNodes[n];\n            if (\n                child.nodeType === Node.COMMENT_NODE ||\n                (child.nodeType === Node.TEXT_NODE && !/\\S/.test(child.nodeValue) && child.nodeValue.includes('\\n'))\n            ) {\n                node.removeChild(child);\n                n--;\n            } else if (child.nodeType === Node.ELEMENT_NODE) {\n                this.clean(child);\n            }\n        }\n    }\n}\n"],"names":["protectecAttributes","constructor","component","keyIndex","html","js","this","_applyVirtualDomFromTemplate","vdom","_applyVirtualDomFromElement","element","clean","newContent","newJs","_parseHTML","undefined","runTemplateJS","_getKeyElementsIndex","dom","result","Map","querySelectorAll","forEach","key","getAttribute","domElement","querySelector","closest","getComponentHash","set","getElement","_diff","_cleanMismatchedComponents","_needsToDiffed","hasChildNodes","_diffChilds","i","childNodes","length","append","cloneNode","_injectContentToElementComponent","isEqualNode","hasAttribute","subcomponent","getElementComponent","componentSelector","getMainSelector","matches","allowTemplateInjection","removeAttribute","injectContent","addAtribute","_sortChildKeyElements","has","newElement","get","insertBefore","_removeUnnecessaryChilds","count","lastChild","remove","_diffElement","nodeType","Node","TEXT_NODE","vdomNode","domNode","_getNodeType","textContent","_patchAttributes","replaceWith","node","ELEMENT_NODE","tagName","toLowerCase","vdomAttributes","_attributesIndex","domAttributes","Object","keys","_updateAttribute","_removeAttribute","name","value","_canUpdateAttribute","setAttribute","includes","_isEditableFormElement","attributes","atts","n","doc","DOMParser","parseFromString","body","childElementCount","Error","firstChild","child","COMMENT_NODE","test","nodeValue","removeChild"],"mappings":"gQAyBMA,oBAAsB,CACxB,0BACA;;;;;;;;;;;mCAsBAC,YAAYC,gBACHA,UAAYA,eACZC,SAAW,0BAUCD,UAAWE,KAAMC,IACf,IAAIC,KAAKJ,WACjBK,6BAA6BH,KAAMC,4BAS1BH,UAAWM,MACZ,IAAIF,KAAKJ,WACjBO,4BAA4BD,6BAUpBE,UACA,IAAIJ,MACZK,MAAMD,SAUrBH,6BAA6BK,WAAYC,aAC/BL,KAAOF,KAAKQ,WAAWF,iBACxBH,4BAA4BD,WACnBO,IAAVF,0BACUG,cAAcH,OAYhCI,qBAAqBT,KAAMU,WACjBC,OAAS,IAAIC,WACYZ,KAAKa,iBAAiB,kBAC9BC,SAAQZ,gBACrBa,IAAMb,QAAQc,aAAa,gBAC3BC,WAAaP,IAAIQ,uCAAgCH,eAClDE,kBAImBA,WAAWE,QAAQ,6BACvBH,aAAa,4BAA8BlB,KAAKJ,UAAU0B,oBAG9ET,OAAOU,IAAIN,IAAKE,eAEbN,OASXV,4BAA4BD,YAClBU,IAAMZ,KAAKJ,UAAU4B,kBACtB3B,SAAWG,KAAKW,qBAAqBT,KAAMU,UAC3Ca,MAAMvB,KAAMU,UACZc,2BAA2Bd,KAUpCa,MAAMvB,KAAMU,QACHZ,KAAK2B,eAAezB,KAAMU,SAIH,IAAxBA,IAAIgB,kBAAsD,IAAzB1B,KAAK0B,qBAOrCC,YAAY3B,KAAMU,cANd,IAAIkB,EAAI,EAAGA,EAAI5B,KAAK6B,WAAWC,OAAQF,IACxClB,IAAIqB,OAAO/B,KAAK6B,WAAWD,GAAGI,WAAU,IAgBpDP,eAAezB,KAAMU,WAC4B,WAAzCA,IAAIM,aAAa,sBAGwB,WAAzCN,IAAIM,aAAa,sBAIoC,IAArDlB,KAAKmC,iCAAiCjC,KAAMU,OAK5CV,KAAKkC,YAAYxB,MAiBzBuB,iCAAiCjC,KAAMU,SAE9BA,IAAIyB,aAAa,4BAClBzB,IAAIM,aAAa,6BAA+BlB,KAAKJ,UAAU0B,0BAExD,QAGLgB,aAAetC,KAAKJ,UAAU2C,oBAAoB3B,SACnD0B,oBACM,QAKLE,kBAAoBF,aAAaG,yBAClCD,mBAAsBtC,KAAKwC,QAAQF,oBAOpCF,cAAgBA,aAAaK,2BAC7B/B,IAAIgC,gBAAgB,kCACpBN,aAAaO,cAAc3C,QAExB,IARHU,IAAIkC,YAAY,iCAAkC,SAC3C,GAkBfpB,2BAA2Bd,KACNA,IAAIG,iBAAiB,oCAC7BC,SAAQZ,UACbA,QAAQwC,gBAAgB,2BACxBxC,QAAQwC,gBAAgB,qCAWhCG,sBAAsB7C,KAAMU,QAC8B,OAAlDV,KAAKkB,cAAc,+BAGlB,IAAIU,EAAI,EAAGA,EAAI5B,KAAK6B,WAAWC,OAAQF,IAAK,OACvCb,IAAMf,KAAK6B,WAAWD,GAAGZ,aAAa,oBACvCD,MAAQjB,KAAKH,SAASmD,IAAI/B,oBAGzBgC,WAAajD,KAAKH,SAASqD,IAAIjC,KACjCL,IAAImB,WAAWD,KAAOmB,YAG1BrC,IAAIuC,aAAaF,WAAYrC,IAAImB,WAAWD,KAWpDsB,yBAAyBlD,KAAMU,QACvBA,IAAImB,WAAWC,QAAU9B,KAAK6B,WAAWC,kBAGzCqB,MAAQzC,IAAImB,WAAWC,OAAS9B,KAAK6B,WAAWC,YAC7CqB,MAAQ,EAAGA,QACdzC,IAAI0C,UAAUC,SAWtB1B,YAAY3B,KAAMU,UACTmC,sBAAsB7C,KAAMU,UAC5BwC,yBAAyBlD,KAAMU,SAC/B,IAAIkB,EAAI,EAAGA,EAAI5B,KAAK6B,WAAWC,OAAQF,SACdrB,IAAtBG,IAAImB,WAAWD,GACflB,IAAIqB,OAAO/B,KAAK6B,WAAWD,GAAGI,WAAU,SAEnCsB,aAAatD,KAAK6B,WAAWD,GAAIlB,IAAImB,WAAWD,IAErD5B,KAAK6B,WAAWD,GAAG2B,WAAaC,KAAKC,gBAChClC,MAAMvB,KAAK6B,WAAWD,GAAIlB,IAAImB,WAAWD,IAY1D0B,aAAaI,SAAUC,SACf7D,KAAK8D,aAAaF,YAAc5D,KAAK8D,aAAaD,SAKlDD,SAASH,WAAaC,KAAKC,UACvBC,SAASG,cAAgBF,QAAQE,cACjCF,QAAQE,YAAcH,SAASG,kBAG9BC,iBAAiBJ,SAAUC,SAThCA,QAAQI,YAAYL,SAAS1B,WAAU,IAoB/C4B,aAAaI,aACLA,KAAKT,UAAYC,KAAKS,aACfD,KAAKE,QAAQC,cAEjBH,KAAKT,SAUhBO,iBAAiB9D,KAAMU,SACf0D,eAAiBtE,KAAKuE,iBAAiBrE,MACvCsE,cAAgBxE,KAAKuE,iBAAiB3D,KACtC0D,gBAAkBE,gBAGtBC,OAAOC,KAAKJ,gBAAgBtD,SAAQC,WAC3B0D,iBAAiB/D,IAAKK,IAAKqD,eAAerD,SAEnDwD,OAAOC,KAAKF,eAAexD,SAAQC,WACHR,IAAxB6D,eAAerD,WACV2D,iBAAiBhE,IAAKK,SAYvC0D,iBAAiB/D,IAAKiE,KAAMC,OACpBlE,IAAIyB,aAAawC,OAASjE,IAAIM,aAAa2D,QAAUC,OAGpD9E,KAAK+E,oBAAoBnE,IAAKiE,OAGnCjE,IAAIoE,aAAaH,KAAMC,OAU3BF,iBAAiBhE,IAAKiE,MACbjE,IAAIyB,aAAawC,OAGjB7E,KAAK+E,oBAAoBnE,IAAKiE,OAGnCjE,IAAIgC,gBAAgBiC,MASxBE,oBAAoBnE,IAAKiE,aACjBnF,oBAAoBuF,SAASJ,SAG7B7E,KAAKkF,uBAAuBtE,SAGxBA,IAAIS,QAAQ,gCAGA,UAATwD,MAA6B,YAATA,MAA+B,aAATA,OAWzDK,uBAAuBtE,WACI,UAAhBA,IAAIwD,SACS,aAAhBxD,IAAIwD,SACY,WAAhBxD,IAAIwD,SACY,WAAhBxD,IAAIwD,QASZG,iBAAiBnE,aACT+E,WAAa,MACS1E,MAAtBL,QAAQ+E,kBACDA,eAEN,IAAIrD,EAAI,EAAGsD,KAAOhF,QAAQ+E,WAAYE,EAAID,KAAKpD,OAAQF,EAAIuD,EAAGvD,IAC/DqD,WAAWC,KAAKtD,GAAG+C,MAAQO,KAAKtD,GAAGgD,aAEhCK,WAUX3E,WAAWV,UAEHwF,KADS,IAAIC,WACAC,gBAAgB1F,KAAM,qBAElCO,MAAMiF,IAAIG,MAEmB,GAA9BH,IAAIG,KAAKC,wBACH,IAAIC,MAAM,mDAGbL,IAAIG,KAAKG,WASpBvF,MAAM6D,UACG,IAAImB,EAAI,EAAGA,EAAInB,KAAKnC,WAAWC,OAAQqD,IAAK,OACvCQ,MAAQ3B,KAAKnC,WAAWsD,GAE1BQ,MAAMpC,WAAaC,KAAKoC,cACvBD,MAAMpC,WAAaC,KAAKC,YAAc,KAAKoC,KAAKF,MAAMG,YAAcH,MAAMG,UAAUf,SAAS,OAE9Ff,KAAK+B,YAAYJ,OACjBR,KACOQ,MAAMpC,WAAaC,KAAKS,mBAC1B9D,MAAMwF"}