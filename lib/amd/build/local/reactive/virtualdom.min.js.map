{"version":3,"file":"virtualdom.min.js","sources":["../../../src/local/reactive/virtualdom.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport Templates from 'core/templates';\n\n/*\n * This code is based on the following articles:\n * https://dev.to/joydeep-bhowmik/virtual-dom-diffing-algorithm-implementation-in-vanilla-javascript-2324\n * https://dev.to/joydeep-bhowmik/adding-keys-our-dom-diffing-algorithm-4d7g\n */\n\n/**\n * Return the node type.\n * @param {HTMLElement} node\n * @returns {String}\n */\nfunction getnodeType(node) {\n    if (node.nodeType == Node.ELEMENT_NODE) {\n        return node.tagName.toLowerCase();\n    } else {\n        return node.nodeType;\n    }\n}\n\n/**\n * Clean the node from comments and empty text nodes.\n *\n * @param {Node} node\n */\nfunction clean(node) {\n    for (var n = 0; n < node.childNodes.length; n++) {\n        var child = node.childNodes[n];\n        if (\n            child.nodeType === Node.COMMENT_NODE ||\n            (child.nodeType === Node.TEXT_NODE && !/\\S/.test(child.nodeValue) && child.nodeValue.includes('\\n'))\n        ) {\n            node.removeChild(child);\n            n--;\n        } else if (child.nodeType === Node.ELEMENT_NODE) {\n            clean(child);\n        }\n    }\n}\n\n/**\n * Parse the html string and return the main element.\n * @param {String} html\n * @returns {HTMLElement}\n */\n// function parseHTML(html) {\n//     const element = document.createElement('div');\n//     element.innerHTML = html;\n\n//     window.console.log(html);\n//     window.console.log(element);\n\n//     if (element.childElementCount != 1) {\n//         throw new Error('The HTML must have only one root element');\n//     }\n\n//     return clean(element.firstElementChild);\n// }\n\n/**\n * Parse the html string and return the main element.\n * @param {String} html\n * @returns {HTMLElement}\n */\nfunction parseHTML(html) {\n    let parser = new DOMParser();\n    let doc = parser.parseFromString(html, 'text/html');\n\n    clean(doc.body);\n\n    if (doc.body.childElementCount != 1) {\n        throw new Error('The HTML must have only one root element');\n    }\n\n    return doc.body.firstChild;\n}\n\n/**\n * Create an index of the attributes of the element.\n *\n * @param {HTMLElement} element\n */\nfunction attrbutesIndex(element) {\n    var attributes = {};\n    if (element.attributes == undefined) {\n        return attributes;\n    }\n    for (var i = 0, atts = element.attributes, n = atts.length; i < n; i++) {\n        attributes[atts[i].name] = atts[i].value;\n    }\n    return attributes;\n}\n\n/**\n * Create an index of the attributes of the element.\n * @param {HTMLElement} vdom the virtual dom element\n * @param {HTMLElement} dom the real dom element\n */\nfunction patchAttributes(vdom, dom) {\n    let vdomAttributes = attrbutesIndex(vdom);\n    let domAttributes = attrbutesIndex(dom);\n    if (vdomAttributes == domAttributes) {\n        return;\n    }\n    Object.keys(vdomAttributes).forEach(key => {\n        // If the attribute is not present in dom then add it.\n        if (!dom.getAttribute(key)) {\n            dom.setAttribute(key, vdomAttributes[key]);\n        } // If the atrtribute is present than compare it.\n        else if (dom.getAttribute(key)) {\n            if (vdomAttributes[key] != domAttributes[key]) {\n                dom.setAttribute(key, vdomAttributes[key]);\n            }\n        }\n    });\n    Object.keys(domAttributes).forEach(key => {\n        // If the attribute is not present in vdom than remove it.\n        if (!vdom.getAttribute(key)) {\n            dom.removeAttribute(key);\n        }\n    });\n}\n\n/**\n * Apply the template to the reactive component main element.\n *\n * @param {HTMLElement} element\n * @param {String} html the template html.\n * @param {String} js the template js.\n */\nfunction applyTemplate(element, html, js) {\n    const newContent = parseHTML(html);\n\n    // const keyIndex = getKeyElementsIndex(newContent, element);\n\n    diff(newContent, element);\n\n    // Temporal: remove all child nodes from the element.\n    // while (element.firstChild) {\n    //     element.removeChild(element.firstChild);\n    // }\n    // Temporal: append the new content children to the element.\n    // while (newContent.firstChild) {\n    //     element.appendChild(newContent.firstChild);\n    // }\n\n    Templates.runTemplateJS(js);\n}\n\n/**\n * Replace all vdom elements with data-mdl-key attribute with the real dom elements.\n *\n * @param {HTMLElement} vdom the virtual dom element\n * @param {HTMLElement} dom the real dom element\n */\n// function replaceKeyElements(vdom, dom) {\n//     const elementsWithDataMdlKey = vdom.querySelectorAll('[data-mdl-key]');\n//     elementsWithDataMdlKey.forEach(element => {\n//         const key = element.getAttribute('data-mdl-key');\n//         const newElement = dom.querySelector(`[data-mdl-key=\"${key}\"]`);\n//         if (!newElement) {\n//             return;\n//         }\n//         // Subcomponents can have the same keys as the parent. We ignore any key that is not part of this component.\n//         const parentComponent = newElement.closest('[data-mdl-component-hash]');\n//         if (parentComponent.getAttribute('data-mdl-component') != dom.getAttribute('data-mdl-component')) {\n//             return;\n//         }\n//         if (newElement) {\n//             element.parentNode.insertBefore(newElement, element);\n//             element.remove();\n//         }\n//     });\n// }\n\n/**\n * Scan all key elements present in the virtual dom and return the list of the dom ones.\n *\n * @param {HTMLElement} vdom the virtual dom element\n * @param {HTMLElement} dom the real dom element\n */\n// function getKeyElementsIndex(vdom, dom) {\n//     const result = new Map();\n//     const elementsWithDataMdlKey = vdom.querySelectorAll('[data-mdl-key]');\n//     elementsWithDataMdlKey.forEach(element => {\n//         const key = element.getAttribute('data-mdl-key');\n//         const newElement = dom.querySelector(`[data-mdl-key=\"${key}\"]`);\n//         if (!newElement) {\n//             return;\n//         }\n//         // Subcomponents can have the same keys as the parent. We ignore any key that is not part of this component.\n//         const parentComponent = newElement.closest('[data-mdl-component-hash]');\n//         if (parentComponent.getAttribute('data-mdl-component') != dom.getAttribute('data-mdl-component')) {\n//             return;\n//         }\n//         result.set(key, newElement);\n//     });\n//     return result;\n// }\n\n/**\n * Replace all indexed elements in the dom with the new ones.\n *\n * @param {HTMLElement} dom\n * @param {Map} keyIndex\n */\n// function replaceIndexedElements(dom, keyIndex) {\n//     keyIndex.forEach((element, key) => {\n//         const newElement = dom.querySelector(`[data-mdl-key=\"${key}\"]`);\n//         if (!newElement) {\n//             return;\n//         }\n//         element.parentNode.insertBefore(newElement, element);\n//         element.remove();\n//     });\n// }\n\n/**\n * Execute a diff.\n * @param {HTMLElement} vdom virtual dom element\n * @param {HTMLElement} dom real dom element\n */\nfunction diff(vdom, dom) {\n    // If dom has no childs then append the childs from vdom.\n    if (dom.hasChildNodes() == false && vdom.hasChildNodes() == true) {\n        for (var i = 0; i < vdom.childNodes.length; i++) {\n            // Appending.\n            dom.append(vdom.childNodes[i].cloneNode(true));\n        }\n    } else {\n        // If both nodes are equal then no need to compare farther.\n        if (vdom.isEqualNode(dom)) {\n            return;\n        }\n        // If dom has extra child.\n        if (dom.childNodes.length > vdom.childNodes.length) {\n            let count = dom.childNodes.length - vdom.childNodes.length;\n            if (count > 0) {\n                for (; count > 0; count--) {\n                    dom.childNodes[dom.childNodes.length - count].remove();\n                }\n            }\n        }\n        // Now comparing all childs.\n        for (let i = 0; i < vdom.childNodes.length; i++) {\n            // If the node is not present in dom append it.\n            if (dom.childNodes[i] == undefined) {\n                dom.append(vdom.childNodes[i].cloneNode(true));\n            } else if (getnodeType(vdom.childNodes[i]) == getnodeType(dom.childNodes[i])) {\n                // If same node type.\n                // If the nodeType is text.\n                if (vdom.childNodes[i].nodeType == Node.TEXT_NODE) {\n                    // We check if the text content is not same.\n                    if (vdom.childNodes[i].textContent != dom.childNodes[i].textContent) {\n                        // Replace the text content.\n                        dom.childNodes[i].textContent = vdom.childNodes[i].textContent;\n                    }\n                } else {\n                    patchAttributes(vdom.childNodes[i], dom.childNodes[i]);\n                }\n            } else {\n                // Replace.\n                dom.childNodes[i].replaceWith(vdom.childNodes[i].cloneNode(true));\n            }\n            if (vdom.childNodes[i].nodeType != Node.TEXT_NODE) {\n                diff(vdom.childNodes[i], dom.childNodes[i]);\n            }\n        }\n    }\n}\n\nexport default {\n    applyTemplate,\n};\n\n\n/**\n * TODO describe module virtualdom\n *\n * @module     core/local/reactive/virtualdom\n * @copyright  2024 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n// class VirtualDOM {\n//     constructor(originalElement, newElement) {\n//         this.originalElement = originalElement;\n//         this.newElement = newElement;\n//     }\n\n//     diff() {\n//         if (this.originalElement.childElementCount > 1 || this.newElement.childElementCount > 1) {\n//             throw new Error('Both the original and new content must have only one root element');\n//         }\n\n//         this.moveElementsWithDataMdlKey();\n//         this.updateElements();\n//     }\n\n//     moveElementsWithDataMdlKey() {\n//         const elementsWithDataMdlKey = this.originalElement.querySelectorAll('[data-mdl-key]');\n//         elementsWithDataMdlKey.forEach(element => {\n//             const key = element.getAttribute('data-mdl-key');\n//             const newElement = this.newElement.querySelector(`[data-mdl-key=\"${key}\"]`);\n//             if (newElement) {\n//                 newElement.appendChild(element);\n//             }\n//         });\n//     }\n\n//     updateElements() {\n//         const elements = this.newElement.querySelectorAll('*:not([data-mdl-reactivecomponent])');\n//         elements.forEach(element => {\n//             const originalElement = this.originalElement.querySelector(\n//                      `[data-mdl-key=\"${element.getAttribute('data-mdl-key')}\"]`\n//             );\n//             if (originalElement) {\n//                 originalElement.replaceWith(element.cloneNode(true));\n//             }\n//         });\n//     }\n// }\n\n// const originalElement = document.getElementById('original-element');\n// const newElement = document.getElementById('new-element');\n\n// const virtualDOM = new VirtualDOM(originalElement, newElement);\n// virtualDOM.diff();\n"],"names":["getnodeType","node","nodeType","Node","ELEMENT_NODE","tagName","toLowerCase","clean","n","childNodes","length","child","COMMENT_NODE","TEXT_NODE","test","nodeValue","includes","removeChild","parseHTML","html","doc","DOMParser","parseFromString","body","childElementCount","Error","firstChild","attrbutesIndex","element","attributes","undefined","i","atts","name","value","patchAttributes","vdom","dom","vdomAttributes","domAttributes","Object","keys","forEach","key","getAttribute","setAttribute","removeAttribute","diff","hasChildNodes","append","cloneNode","isEqualNode","count","remove","textContent","replaceWith","applyTemplate","js","runTemplateJS"],"mappings":"qHA4BSA,YAAYC,aACbA,KAAKC,UAAYC,KAAKC,aACfH,KAAKI,QAAQC,cAEbL,KAAKC,kBASXK,MAAMN,UACN,IAAIO,EAAI,EAAGA,EAAIP,KAAKQ,WAAWC,OAAQF,IAAK,KACzCG,MAAQV,KAAKQ,WAAWD,GAExBG,MAAMT,WAAaC,KAAKS,cACvBD,MAAMT,WAAaC,KAAKU,YAAc,KAAKC,KAAKH,MAAMI,YAAcJ,MAAMI,UAAUC,SAAS,OAE9Ff,KAAKgB,YAAYN,OACjBH,KACOG,MAAMT,WAAaC,KAAKC,cAC/BG,MAAMI,iBA6BTO,UAAUC,UAEXC,KADS,IAAIC,WACAC,gBAAgBH,KAAM,gBAEvCZ,MAAMa,IAAIG,MAEwB,GAA9BH,IAAIG,KAAKC,wBACH,IAAIC,MAAM,mDAGbL,IAAIG,KAAKG,oBAQXC,eAAeC,aAChBC,WAAa,MACSC,MAAtBF,QAAQC,kBACDA,eAEN,IAAIE,EAAI,EAAGC,KAAOJ,QAAQC,WAAYrB,EAAIwB,KAAKtB,OAAQqB,EAAIvB,EAAGuB,IAC/DF,WAAWG,KAAKD,GAAGE,MAAQD,KAAKD,GAAGG,aAEhCL,oBAQFM,gBAAgBC,KAAMC,SACvBC,eAAiBX,eAAeS,MAChCG,cAAgBZ,eAAeU,KAC/BC,gBAAkBC,gBAGtBC,OAAOC,KAAKH,gBAAgBI,SAAQC,MAE3BN,IAAIO,aAAaD,KAGbN,IAAIO,aAAaD,MAClBL,eAAeK,MAAQJ,cAAcI,MACrCN,IAAIQ,aAAaF,IAAKL,eAAeK,MAJzCN,IAAIQ,aAAaF,IAAKL,eAAeK,SAQ7CH,OAAOC,KAAKF,eAAeG,SAAQC,MAE1BP,KAAKQ,aAAaD,MACnBN,IAAIS,gBAAgBH,kBAwGvBI,KAAKX,KAAMC,QAEW,GAAvBA,IAAIW,iBAAoD,GAAxBZ,KAAKY,oBAChC,IAAIjB,EAAI,EAAGA,EAAIK,KAAK3B,WAAWC,OAAQqB,IAExCM,IAAIY,OAAOb,KAAK3B,WAAWsB,GAAGmB,WAAU,QAEzC,IAECd,KAAKe,YAAYd,eAIjBA,IAAI5B,WAAWC,OAAS0B,KAAK3B,WAAWC,OAAQ,KAC5C0C,MAAQf,IAAI5B,WAAWC,OAAS0B,KAAK3B,WAAWC,UAChD0C,MAAQ,OACDA,MAAQ,EAAGA,QACdf,IAAI5B,WAAW4B,IAAI5B,WAAWC,OAAS0C,OAAOC,aAKrD,IAAItB,EAAI,EAAGA,EAAIK,KAAK3B,WAAWC,OAAQqB,IAEfD,MAArBO,IAAI5B,WAAWsB,GACfM,IAAIY,OAAOb,KAAK3B,WAAWsB,GAAGmB,WAAU,IACjClD,YAAYoC,KAAK3B,WAAWsB,KAAO/B,YAAYqC,IAAI5B,WAAWsB,IAGjEK,KAAK3B,WAAWsB,GAAG7B,UAAYC,KAAKU,UAEhCuB,KAAK3B,WAAWsB,GAAGuB,aAAejB,IAAI5B,WAAWsB,GAAGuB,cAEpDjB,IAAI5B,WAAWsB,GAAGuB,YAAclB,KAAK3B,WAAWsB,GAAGuB,aAGvDnB,gBAAgBC,KAAK3B,WAAWsB,GAAIM,IAAI5B,WAAWsB,IAIvDM,IAAI5B,WAAWsB,GAAGwB,YAAYnB,KAAK3B,WAAWsB,GAAGmB,WAAU,IAE3Dd,KAAK3B,WAAWsB,GAAG7B,UAAYC,KAAKU,WACpCkC,KAAKX,KAAK3B,WAAWsB,GAAIM,IAAI5B,WAAWsB,gKAMzC,CACXyB,uBA9ImB5B,QAAST,KAAMsC,IAKlCV,KAJmB7B,UAAUC,MAIZS,4BAWP8B,cAAcD;;;;;;;"}