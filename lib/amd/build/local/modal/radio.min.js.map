{"version":3,"file":"radio.min.js","sources":["../../../src/local/modal/radio.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * A radio buttons selector modal.\n *\n * @module     core/local/modal/radio\n * @copyright  2023 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Modal from 'core/modal';\nimport ModalEvents from 'core/modal_events';\nimport Notification from 'core/notification';\nimport Pending from 'core/pending';\nimport Templates from 'core/templates';\nimport {getFirst} from 'core/normalise';\n\nconst selectors = {\n    OPTIONSRADIO: `[type='radio']`,\n};\n\n/**\n * The Radio selection modal.\n *\n * @class\n * @extends module:core/modal\n */\nexport default class extends Modal {\n    /**\n     * The component descriptor data structure.\n     *\n     * @typedef {Object} RadioOption\n     * @property {String} value the option value\n     * @property {String} name the displayed option name\n     * @property {String} [description] the option optional description\n     * @property {String} [id] the optional input element id\n     * @property {String} [icon] an optional option icon\n     * @property {Boolean} [disable] optional option disable\n     * @property {Boolean} [selected] optional option selected\n     */\n\n    /**\n     * Modal constructor.\n     * @param {object} root The root jQuery element for the modal\n     */\n    constructor(root) {\n        // Modal is still using jQuery internally.\n        super(root);\n\n        if (!this.getFooter().find(this.getActionSelector('save')).length) {\n            Notification.exception({message: 'No save button found'});\n        }\n\n        if (!this.getFooter().find(this.getActionSelector('cancel')).length) {\n            Notification.exception({message: 'No cancel button found'});\n        }\n\n        this.modalSetupPromise = new Pending('core/modal:radioModalSetup' + this.getModalCount());\n\n        this.optionsCount = 0;\n        this.selectedValue = null;\n\n        // The save button is not enabled until the user selects an option.\n        this.setButtonDisabled('save', true);\n    }\n\n    /**\n     * Returns the radio options ready promise.\n     * @returns {Promise}\n     */\n    getRadioReadyPromise() {\n        return this.modalSetupPromise;\n    }\n\n    /**\n     * Return the current user selected option.\n     * @returns {String|null}\n     */\n    getSelectedValue() {\n        return this.selectedValue;\n    }\n\n    /**\n     * Register all event listeners.\n     */\n    registerEventListeners() {\n        super.registerEventListeners();\n        this.registerCloseOnSave();\n        this.registerCloseOnCancel();\n    }\n\n    /**\n     * Override parent implementation to prevent changing the footer content.\n     */\n    setFooter() {\n        Notification.exception({message: 'Can not change the footer of a radio modal'});\n        return;\n    }\n\n    /**\n     * Set the title of the save button.\n     *\n     * @param {String|Promise} value The button text, or a Promise which will resolve it\n     * @returns{Promise}\n     */\n    setSaveButtonText(value) {\n        return this.setButtonText('save', value);\n    }\n\n    /**\n     * Return the current selected radio button if any.\n     *\n     * Note: this method will return undefined once the modal is distroyed.\n     *\n     * @return {HTMLElement|undefined}\n     */\n    getSelectedRadio() {\n        const modalBody = getFirst(this.getBody());\n        return modalBody?.querySelector(`${selectors.OPTIONSRADIO}:checked`);\n    }\n\n    /**\n     * Set modal body using the array of options.\n     * @param {RadioOption[]} options the body options descriptor.\n     */\n    async setBody(options) {\n        if (!Array.isArray(options)) {\n            Notification.exception({message: 'Radio modal body should be an array of options'});\n        }\n\n        const modalOptions = [];\n        for (const option of options) {\n            const normalizedOption = await this._normaliseOptionObject(option);\n            modalOptions.push(normalizedOption);\n        }\n\n        const bodyPromise = Templates.render('core/local/modal/radiobody', {options: modalOptions});\n\n        this.getRoot().on(ModalEvents.bodyRendered, () => {\n            if (this.selectedValue !== null) {\n                this.setButtonDisabled('save', false);\n            }\n            this._registerRadioEventListeners();\n        });\n        super.setBody(bodyPromise);\n    }\n\n    /**\n     * Get an option data and add return a choice with all necessary data.\n     * @private\n     * @param {Object} option\n     * @returns {Object}\n     */\n    async _normaliseOptionObject(option) {\n        this.optionsCount++;\n\n        if (option.value === undefined || option.name === undefined) {\n            Notification.exception({message: 'Missing name or value in radio modal option.'});\n        }\n        const modalOption = {\n            value: option.value,\n            name: option.name,\n            optionid: option.id ?? `radioModalOption${this.optionsCount}`,\n            optionnumber: this.optionsCount,\n        };\n        if (this.optionsCount == 1) {\n            modalOption.first = true;\n        }\n        // Prevent mustache from missinterpretating any false optional attributes.\n        if (option.description) {\n            modalOption.description = option.description;\n        }\n        if (option.icon) {\n            modalOption.icon = option.icon;\n        }\n        if (option.disabled) {\n            modalOption.disabled = true;\n        }\n        if (option.selected) {\n            this.selectedValue = option.value;\n            modalOption.selected = true;\n        }\n        // Assume non-string values are Promises to be resolved.\n        for (const awaitValue of ['name', 'description', 'icon']) {\n            if (modalOption[awaitValue] !== undefined && typeof modalOption[awaitValue] !== 'string') {\n                modalOption[awaitValue] = await modalOption[awaitValue];\n            }\n        }\n        return modalOption;\n    }\n\n    /**\n     * Internal method to register Radio Selection Events.\n     * @private\n     */\n    _registerRadioEventListeners() {\n        const modalBody = getFirst(this.getBody());\n        const radioOptions = modalBody.querySelectorAll(selectors.OPTIONSRADIO);\n        radioOptions.forEach(radio => {\n            radio.addEventListener('change', () => {\n                this._updateSelectedValue();\n                this.setButtonDisabled('save', false);\n            });\n            radio.parentNode.addEventListener('click', () => {\n                if (radio.disabled) {\n                    return;\n                }\n                radio.checked = true;\n                this._updateSelectedValue();\n                this.setButtonDisabled('save', false);\n            });\n            const submitHandler = (event) => {\n                if (radio.disabled) {\n                    return;\n                }\n                event.preventDefault();\n                this._updateSelectedValue();\n                this.dispatchActionEvent(ModalEvents.save);\n            };\n            radio.parentNode.addEventListener('dblclick', submitHandler);\n            radio.addEventListener(\n                'keydown',\n                (event) => {\n                    // Old Firefox versions use \"Space\" instead of \" \".\n                    if ([\"Enter\", \" \", \"Space\"].includes(event.key)) {\n                        submitHandler(event);\n                    }\n                });\n        });\n        this.modalSetupPromise.resolve();\n    }\n\n    /**\n     * Update the selected value attributte.\n     * @private\n     */\n    _updateSelectedValue() {\n        const originalValue = this.selectedValue;\n        const selectedRadio = this.getSelectedRadio();\n        if (selectedRadio) {\n            this.selectedValue = selectedRadio.value;\n        }\n        if (originalValue !== this.selectedValue) {\n            this._dispatchValueChangedEvent();\n        }\n    }\n\n    /**\n     * Dispatch a value change event.\n     * @private\n     */\n    _dispatchValueChangedEvent() {\n        const target = getFirst(this.getRoot());\n        if (target === undefined) {\n            target = document;\n        }\n        target.dispatchEvent(new CustomEvent(\n            ModalEvents.radioChanged,\n            {bubbles: true, detail: this}\n        ));\n    }\n}\n"],"names":["selectors","Modal","constructor","root","this","getFooter","find","getActionSelector","length","exception","message","modalSetupPromise","Pending","getModalCount","optionsCount","selectedValue","setButtonDisabled","getRadioReadyPromise","getSelectedValue","registerEventListeners","registerCloseOnSave","registerCloseOnCancel","setFooter","setSaveButtonText","value","setButtonText","getSelectedRadio","modalBody","getBody","querySelector","options","Array","isArray","modalOptions","option","normalizedOption","_normaliseOptionObject","push","bodyPromise","Templates","render","getRoot","on","ModalEvents","bodyRendered","_registerRadioEventListeners","setBody","undefined","name","modalOption","optionid","id","optionnumber","first","description","icon","disabled","selected","awaitValue","querySelectorAll","forEach","radio","addEventListener","_updateSelectedValue","parentNode","checked","submitHandler","event","preventDefault","dispatchActionEvent","save","includes","key","resolve","originalValue","selectedRadio","_dispatchValueChangedEvent","target","document","dispatchEvent","CustomEvent","radioChanged","bubbles","detail"],"mappings":";;;;;;;iUA8BMA,+DAUuBC,eAkBzBC,YAAYC,YAEFA,MAEDC,KAAKC,YAAYC,KAAKF,KAAKG,kBAAkB,SAASC,8BAC1CC,UAAU,CAACC,QAAS,yBAGhCN,KAAKC,YAAYC,KAAKF,KAAKG,kBAAkB,WAAWC,8BAC5CC,UAAU,CAACC,QAAS,gCAGhCC,kBAAoB,IAAIC,iBAAQ,6BAA+BR,KAAKS,sBAEpEC,aAAe,OACfC,cAAgB,UAGhBC,kBAAkB,QAAQ,GAOnCC,8BACWb,KAAKO,kBAOhBO,0BACWd,KAAKW,cAMhBI,+BACUA,8BACDC,2BACAC,wBAMTC,kCACiBb,UAAU,CAACC,QAAS,+CAUrCa,kBAAkBC,cACPpB,KAAKqB,cAAc,OAAQD,OAUtCE,yBACUC,WAAY,uBAASvB,KAAKwB,kBACzBD,MAAAA,iBAAAA,UAAWE,wBAAiB7B,kDAOzB8B,SACLC,MAAMC,QAAQF,gCACFrB,UAAU,CAACC,QAAS,yDAG/BuB,aAAe,OAChB,MAAMC,UAAUJ,QAAS,OACpBK,uBAAyB/B,KAAKgC,uBAAuBF,QAC3DD,aAAaI,KAAKF,wBAGhBG,YAAcC,mBAAUC,OAAO,6BAA8B,CAACV,QAASG,oBAExEQ,UAAUC,GAAGC,sBAAYC,cAAc,KACb,OAAvBxC,KAAKW,oBACAC,kBAAkB,QAAQ,QAE9B6B,wCAEHC,QAAQR,0CASWJ,4BACpBpB,oBAEgBiC,IAAjBb,OAAOV,YAAuCuB,IAAhBb,OAAOc,4BACxBvC,UAAU,CAACC,QAAS,uDAE/BuC,YAAc,CAChBzB,MAAOU,OAAOV,MACdwB,KAAMd,OAAOc,KACbE,4BAAUhB,OAAOiB,8DAAyB/C,KAAKU,cAC/CsC,aAAchD,KAAKU,cAEE,GAArBV,KAAKU,eACLmC,YAAYI,OAAQ,GAGpBnB,OAAOoB,cACPL,YAAYK,YAAcpB,OAAOoB,aAEjCpB,OAAOqB,OACPN,YAAYM,KAAOrB,OAAOqB,MAE1BrB,OAAOsB,WACPP,YAAYO,UAAW,GAEvBtB,OAAOuB,gBACF1C,cAAgBmB,OAAOV,MAC5ByB,YAAYQ,UAAW,OAGtB,MAAMC,aAAc,CAAC,OAAQ,cAAe,aACbX,IAA5BE,YAAYS,aAAgE,iBAA5BT,YAAYS,cAC5DT,YAAYS,kBAAoBT,YAAYS,oBAG7CT,YAOXJ,gCACsB,uBAASzC,KAAKwB,WACD+B,iBAAiB3D,wBACnC4D,SAAQC,QACjBA,MAAMC,iBAAiB,UAAU,UACxBC,4BACA/C,kBAAkB,QAAQ,MAEnC6C,MAAMG,WAAWF,iBAAiB,SAAS,KACnCD,MAAML,WAGVK,MAAMI,SAAU,OACXF,4BACA/C,kBAAkB,QAAQ,aAE7BkD,cAAiBC,QACfN,MAAML,WAGVW,MAAMC,sBACDL,4BACAM,oBAAoB1B,sBAAY2B,QAEzCT,MAAMG,WAAWF,iBAAiB,WAAYI,eAC9CL,MAAMC,iBACF,WACCK,QAEO,CAAC,QAAS,IAAK,SAASI,SAASJ,MAAMK,MACvCN,cAAcC,kBAIzBxD,kBAAkB8D,UAO3BV,6BACUW,cAAgBtE,KAAKW,cACrB4D,cAAgBvE,KAAKsB,mBACvBiD,qBACK5D,cAAgB4D,cAAcnD,OAEnCkD,gBAAkBtE,KAAKW,oBAClB6D,6BAQbA,mCACUC,QAAS,uBAASzE,KAAKqC,gBACdM,IAAX8B,SACAA,OAASC,UAEbD,OAAOE,cAAc,IAAIC,YACrBrC,sBAAYsC,aACZ,CAACC,SAAS,EAAMC,OAAQ/E"}